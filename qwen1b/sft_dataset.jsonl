{"prefix": "def get_markdown(text):     if not text:         return \"\"      pattern = fr'([\\[\\s\\S\\]]*?)\\(([\\s\\S]*?):([\\[\\s\\S\\]]*?)\\)'     # Regex check     if re.match(pattern, text):         # get get value of group regex", "suffix": "group = re.search(pattern, text)         # get the value of group 1 (text)         text = group.group(1)         # get the value of group 2 (link)         link = group.group(2)         # get the value of group 3 (title)         title ="}
{"prefix": "class NbconvertFileHandler(IPythonHandler):      SUPPORTED_METHODS = ('GET',)      @web.authenticated     def get(self, format, path):  def get(self, format, path): class NbconvertPostHandler(IPythonHandler):     SUPPORTED_METHODS = ('POST',)      @web", "suffix": ".authenticated     def post(self, format, path):  def post(self, format, path): class NbconvertFileHandler(IPythonHandler):      SUPPORTED_METHODS = ('GET',)      @web.authenticated     def get(self, format, path):  def get(self, format, path): class Nb"}
{"prefix": "def key(request, wikiname=None, itemname=None, attachname=None, content=None, se     return key   def put(request, key, data,         filename=None,         content_type=None, def _do_remove(request, key):     remove(request, key)   def _do(request, do, key", "suffix": ", data,         filename=None,         content_type=None,         content=None,         se     return do(request, do, key, data,         filename,         content_type,         content,         se     def _do_put(request, key, data,         filename=None,         content_type=None,         content=None"}
{"prefix": "async def message(self, ctx: commands.Context):      @message.command(name=\"mention\")     @commands.guild_only()     async def with_mention(self, ctx: commands.Context, message: str = None):         \"\"\"Set stream alert message when mentions are enabled.          Use `{mention}` in the message to insert", "suffix": "the user's mention. \"\"\"         if message is None:             message = \"Stream alert: {mention} is online!\"         await self.bot.settings.set(ctx.guild, \"stream_alert_message\", message)         await ctx.send(f\"Stream alert message set to: {message}\")     @message.command(name=\"disable\")"}
{"prefix": "import sys import datetime from functools import wraps from werkzeug.utils import secure_filename from werkzeug.security import generate_password_hash, check_password_hash from flask import Flask, request, jsonify, render_template, flash, redirect, url_for, session, send_file, make_response from flask_login import login_user, login_required, logout", "suffix": "_user, current_user, UserMixin, LoginManager from flask_sqlalchemy import SQLAlchemy from flask_mail import Mail, Message from flask_bcrypt import Bcrypt from flask_cors import CORS from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity, set_access_token, unset_access_token, verify"}
{"prefix": "from apkleaks.colors import clr from contextlib import closing from distutils.spawn import find_executable from pyaxmlparser import APK from urllib.request import urlopen from zipfile import ZipFile def decompile(self): \t\t\t\t\tclasses.write(zipped.read(\"classes.dex\")) \t\t\texcept Exception as e: \t\t\t\tsys.exit(self", "suffix": ".error(\"Failed to decompile APK: %s\" % e)) def extract(self): \t\t\tclasses.write(zipped.read(\"classes.dex\")) \t\t\texcept Exception as e: \t\t\t\tsys.exit(self.error(\"Failed to extract APK: %s\" % e)) def extract(self): \t\t\tclasses.write(zipped.read(\""}
{"prefix": "def visit_Call(self, node):         datetime().         \"\"\"         if isinstance(node.func, ast.Name):             expr = None             if node.func.id == 'ObjectId':                 expr = \"('\" + node.args[0].s + \"')\"             elif node.func.id == 'datetime':                 values = []                 for", "suffix": "arg in node.args:                     if isinstance(arg, ast.Str):                         values.append(\"'\" + arg.s + \"'\")                     elif isinstance(arg, ast.Num):                         values.append(str(arg.n))                     elif isinstance(arg, ast.NameConstant):                         values.append(str(arg.value))                     elif isinstance(arg, ast.List):                         values"}
{"prefix": "import ctypes import logging import libarchive  from diffoscope.tempfiles import get_temporary_directory  def close_archive(self):      def get_member_names(self):         self.ensure_unpacked()         return self._member_names      def extract(self, member_name, dest_dir):         self.ensure_unpacked()         return os.path", "suffix": ".join(dest_dir, self._extract_member(member_name))      def ensure_unpacked(self):         if not self._is_packed:            self._unpack()      def _unpack(self):         self._member_names = get_member_names(self)         self._is_packed = True      def _extract_member(self,"}
{"prefix": "import os  from aim.web.api.utils import APIRouter  # wrapper for fastapi.APIRouter from fastapi.responses import FileResponse  statics_router = APIRouter()   @statics_router.get('/static-files/{path:path}/') async def serve_static_files(path):     from aim import web     static_file_name", "suffix": "= os.path.join(web.statics_dir, path)     if os.path.exists(static_file_name):         return FileResponse(static_file_name)     else:         return FileResponse('static-files/404.html')   @statics_router.get('/static-files/{path:path}') async def serve_static_files(path):"}
{"prefix": "def get_int_arg(value, default=0):             num_dag_to=min(end, num_of_all_dags),             num_of_all_dags=num_of_all_dags,             paging=wwwutils.generate_pages(current_page, num_of_pages,                                            search=arg_search_query,                                            showPaused=not hide_pa", "suffix": "used,                                            showCompleted=not hide_completed,                                            showRunning=not hide_running,                                            showPausedAndCompleted=not hide_paused_and_completed,                                            showPausedAndRunning=not hide_paused_and_running,                                            showCompletedAndRunning=not hide_completed_and_running,                                            showCompletedAndPaused=not hide"}
{"prefix": "import re import inspect  __version__ = '0.8' __author__ = 'Hsiaoming Yang <me@lepture.com>' __all__ = [     'BlockGrammar', 'BlockLexer', def _pure_pattern(regex):   def _keyify(key):     return _key_pattern", "suffix": "(key)   def _key_pattern(key):     return re.compile(r'\\b%s\\b' % key)   def _pattern(key):     return _pure_pattern(regex % key)   return _pattern def _key_pattern(key):   return re.compile(r'\\b%s\\b' % key) def _pattern(key"}
{"prefix": "async def get_resolved_ref(self):             self.sha1_validate(self.unresolved_ref)         except ValueError:             # The ref is a head/tag and we resolve it using `git ls-remote`             command = [\"git\", \"ls-remote\", self.repo, self.unresolved_ref]             result = subprocess", "suffix": ".run(command, capture_output=True, text=True)             if result.returncode != 0:                 raise ValueError(f\"Failed to resolve ref {self.unresolved_ref}\")             self.sha1_validate(result.stdout.strip())         return self.sha1_validate(self.unresolved_ref) ``` In this solution, the `get_resolved"}
{"prefix": "def before_upstream_connection(                 raise ProxyAuthenticationFailed()             parts = request.headers[b'proxy-authorization'][1].split()             if len(parts) != 2 \\                     and parts[0].lower() != b'basic' \\                     and parts[1] != self.flags.auth_code:                 raise", "suffix": "ProxyAuthenticationFailed()             self.flags.auth_code = parts[1]             self.flags.auth_type = parts[0].lower()             self.flags.auth_user = parts[1]             self.flags.auth_pass = parts[2]             self.flags.auth_method = 'basic'             self.flags.auth_header = b'Proxy"}
{"prefix": "def _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,     if max_depth > scalar_depth:       raise ValueError(\"Invalid pylist=%r: empty list nesting is greater \"                        \"than scalar value nesting\" % pylist)    # If both inner_shape and ragged", "suffix": "_shape are None, then the ragged factory is    # used to create a new ragged tensor.    if inner_shape is None and ragged_shape is None:       return ragged_factory.from_value(pylist, dtype, ragged_rank)    # If both inner_shape and ragged_shape are not None,"}
{"prefix": "def _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,     if max_depth > scalar_depth:       raise ValueError(\"Invalid pylist=%r: empty list nesting is greater \"                        \"than scalar value nesting\" % pylist)    # If both inner_shape and ragged", "suffix": "_shape are None, then the ragged factory is    # used to create a new ragged tensor.    if inner_shape is None and ragged_shape is None:       return ragged_factory.from_value(pylist, dtype, ragged_rank)    # If both inner_shape and ragged_shape are not None,"}
{"prefix": "def word_tokenize(self, s):         return self._word_tokenizer_re().findall(s)      _period_context_fmt = r\"\"\"         \\S*                          # some word material         %(SentEndChars)s             # a potential sentence ending         (?=(?P<after_tok>             %(NonWord)s             ", "suffix": "# a non-word character             \\S*                          # some word material             %(SentEndChars)s             # a potential sentence ending         ))\"\"\"         _period_context_re = re.compile(self._period_context_fmt, re.VERBOSE)         _sentence_end_chars = r\"\"\"         [.,:;!?]\"\"\""}
{"prefix": "def copy_with(self, **kwargs: typing.Any) -> \"URL\":         #  \\_/   \\______________/\\_________/ \\_________/ \\__/         #   |           |            |            |        |         # scheme     authority       path        query   fragment         return URL(self._uri_reference.copy_with", "suffix": "(**kwargs))         #   |           |            |            |        |         # \\_________/ \\_________/ \\_________/ \\__/         #   |           |            |            |        |         # \\_________/ \\_________/ \\_________/ \\__/         #   |           |            |            |"}
{"prefix": "def makecmdoptions(self):     def __str__(self):         return \"<SvnAuth username=%s ...>\" %(self.username,)  rex_blame = re.compile(r'\\s*(\\d+)\\s*(\\S+) (.*)')  class SvnWCCommandPath(common.PathBase):     \"\"\" path", "suffix": "to a working copy \"\"\"     def __init__(self, path, **kwargs):         super(SvnWCCommandPath, self).__init__(path, **kwargs)     def __str__(self):         return \"<SvnWCCommandPath path=%s ...>\" %(self.path,)  class SvnWCCommand"}
{"prefix": "'transparent': (0, 0, 0, 0), }  RGBA = re.compile(r'rgba\\([ \\n\\r\\t]*(.+?)[ \\n\\r\\t]*\\)') RGB = re.compile(r'rgb\\([ \\n\\r\\t]*(.+?)[ \\n\\r\\t]*", "suffix": "\\)') HEX = re.compile(r'#[0-9a-fA-F]{6}') def parse_color(color): \"\"\" Parse a color string and return a tuple of RGBA values. \"\"\" if color.startswith('rgba('): return tuple(map(float, RGBA.search(color).group(1).split(','))) elif color.startswith"}
{"prefix": "import typing  import flask  app = flask.Flask(\"xmpp-http-upload\") app.config.from_envvar(\"XMPP_HTTP_UPLOAD_CONFIG\")     CORS(app)   def sanitized_join(path: str, root: pathlib.Path) -> pathlib.Path:     result = (root / path).absolute()     if not str", "suffix": "(result).startswith(str(root)):         raise ValueError(\"Path traversal detected\")     return result     @app.route(\"/upload\", methods=[\"POST\"])     def upload():         root = pathlib.Path(app.config[\"UPLOAD_ROOT\"])         if not root.exists():             raise ValueError(\"Upload root does not exist\")         if not root.is"}
{"prefix": "def __str__(self):   class Application:     SOCKTYPES = {         \"tcp\": socket.SOCK_STREAM,         \"udp\": socket.SOCK_DGRAM, def __call__(self, env, start_response):             try:                 length = int(env[\"CONTENT_LENGTH\"])             except AttributeError:                 length = -1            ", "suffix": "except ValueError:                 length = -1             if length == -1:                 body = b\"\"             else:                 body = env[\"wsgi.input\"].read(length)             if body:                 body = body.decode(\"utf-8\")             else:                 body = \"\"             start_response(\"200 OK"}
{"prefix": "def branch_exists(self, branch):         \"\"\"         try:             heads = subprocess.run(                 [\"git\", \"ls-remote\", \"--heads\", self.git_url],                 capture_output=True,                 text=True,                 check=True             )             tags = subprocess.run(                 [\"git\", \"ls-remote\", \"--", "suffix": "tags\", self.git_url],                 capture_output=True,                 text=True,                 check=True             )             branches = subprocess.run(                 [\"git\", \"ls-remote\", \"--branches\", self.git_url],                 capture_output=True,                 text=True,                 check=True             )             branches = branches.stdout.splitlines()"}
{"prefix": "def _unzip_iter(filename, root, verbose=True):         yield ErrorMessage(filename, e)         return      # Get lists of directories & files     namelist = zf.namelist()     dirlist = set()     for x in namelist:         if x.endswith('/'):             dirlist.add(x)        ", "suffix": "else:             dirlist.add(os.path.dirname(x))     # Create a dictionary of directories & files     dirfiles = dict()     for x in dirlist:         dirfiles[x] = []     for x in namelist:         if x.endswith('/'):             continue         dirfiles[x.split('/')[-2]].append"}
{"prefix": "import mimetypes import os import os.path import re import socketserver import threading def condition():         if path == \"/js/livereload.js\":             file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"livereload.js\")         elif path.startswith(self.mount_path):             rel_file_path", "suffix": "= path[len(self.mount_path):]             file_path = os.path.join(self.static_dir, rel_file_path)         else:             return False         if not os.path.exists(file_path):             return False         return True def get_content_type(file_path):         return mimetypes.guess_type(file_path)[0] def"}
{"prefix": "def parse_native_url(url):         result = re.match(             r'^https?://maker\\.ifttt\\.com/use/'             r'(?P<webhook_id>[A-Z0-9_-]+)'             r'/?(?P<events>([A-Z0-9_-]+/?)+)?", "suffix": "$',             url,             re.IGNORECASE)             if result:                 return result.groupdict()             else:                 return None\n```\n\nThis function uses regular expressions to match the URL format and extract the webhook ID and events from the URL. The function returns a dictionary containing the extracted information if the URL matches the expected"}
{"prefix": "def interpret(): @app.route(\"/file/<path:path>\", methods=[\"GET\"]) @login_check def file(path):     path = secure_filename(path)     if app.interface.encrypt and isinstance(app.interface.examples, str) and path.startswith(app.interface.examples):         with open(os.path.join(app.cwd, path), \"rb\")", "suffix": "as f:             return f.read()     return send_from_directory(app.cwd, path) @app.route(\"/file/<path:path>\", methods=[\"POST\"]) @login_check def file_post(path):     path = secure_filename(path)     if app.interface.encrypt and isinstance(app.interface.examples, str) and path.startswith(app.interface"}
{"prefix": "import os import re from collections import defaultdict  from flask import (     Response, def _add_additional_assets(hook): def login():     from flask_login import current_user      redirect_url = request.args.get(\"redirect\", request.script_root + url_for(\"index\"))     permissions = sorted(         filter(             lambda x", "suffix": ": x[0] in current_user.permissions,             current_user.permissions,         ),         key=lambda x: x[1],     )     return render_template(\"login.html\", permissions=permissions, redirect_url=redirect_url) def logout():     from flask_login import logout_user      logout_user()     return redirect(url"}
{"prefix": "import os import Bcfg2.Server.Plugin   def async_run(prog, args):     pid = os.fork()     if pid:         os.waitpid(pid, 0)     else:         dpid = os.fork()         if not dpid:             os.system(\" \".join([prog] + args", "suffix": "))             os._exit(0)         else:             os.waitpid(dpid, 0)             os._exit(0) def async_run(prog, args):     pid = os.fork()     if pid:         os.waitpid(pid, 0)     else:         dpid = os.f"}
{"prefix": "class AffinityFilter(filters.BaseHostFilter):     def __init__(self):         self.compute_api = compute.API()      def _affinity_host(self, context, instance_id):         return self.compute_api.get(context, instance_id)['host']   class DifferentHostFilter(AffinityFilter): def host_passes", "suffix": "(self, context, instance, host):         return host != self._affinity_host(context, instance['uuid'])   class DifferentHostFilter2(AffinityFilter): def host_passes(self, context, instance, host):         return host != self._affinity_host(context, instance['uuid'])   class Different"}
{"prefix": "from django.conf import settings from django.contrib import messages from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ from keystoneclient import exceptions as keystone_exceptions  def handle(self, request, data):         request.session['region_endpoint'] = endpoint         request.session['region_name'] =", "suffix": "region_name         request.session['region_id'] = region_id         request.session['region_token'] = region_token         request.session['region_project_id'] = region_project_id         request.session['region_project_name'] = region_project_name         request.session['region_user_id'] = region_user_id         request.session['region_user"}
{"prefix": "def configure():     register_cli_str('pydev-debug-host', default=None)     register_cli_int('pydev-debug-port', default=None)      register_str('admin_token', default='ADMIN')     register_str('bind_host', default='0.0.0.0')     register_int('compute_port',", "suffix": "default=8080)     register_int('compute_api_port', default=8081)     register_int('compute_api_v2_port', default=8082)     register_int('compute_api_v3_port', default=8083)     register_int('compute_api_v4"}
{"prefix": "def nav_path(request):     path_parts.append(part)     is_last = len(path_parts) == len(request.path_parts)      item = _item(name=part, href=None)      if not is_last or (is_dir and request.view_func is not view_directory):       item.href = request.get_url(view_func", "suffix": "=nav_path, path_parts=path_parts)      return item\n```\n\n**Explanation**:\nThe function `nav_path` is designed to generate a navigation path based on the current request. It takes a `request` object as input and returns a list of navigation items. Each item represents a part of the path and"}
{"prefix": "def _checkPolkitPrivilege(self, sender, conn, privilege):             # bus, and it does not make sense to restrict operations here             return          info = SenderInfo(sender, conn)          # get peer PID         pid = info.connectionPid()          # query PolicyKit         self._initPolkit()", "suffix": "# get the PolicyKit session ID         sessionID = self._getPolkitSessionID(pid)          # check if the privilege is granted          granted = self._checkPolkitPrivilege(sessionID, privilege)          # return the result          return granted\n```\nThe function `_checkPolkitPrivilege`"}
{"prefix": "def encode(self):  def constructObject(data):     try:         classBase = eval(data[\"\"] + \".\" + data[\"\"].title())     except NameError:         logger.error(\"Don't know how to handle message type: \\\"%s\\\"\", data[\"\"])         return None     try:         returnObj = class", "suffix": "Base()     except Exception as e:         logger.error(\"Failed to construct object of type: \\\"%s\\\". Error: %s\", data[\"\"], e)         return None     for key, value in data.items():         if key == \"\":             continue         if key == \"\":             continue         if key"}
{"prefix": "def sendEmail(sydent, templateName, mailTo, substitutions):             allSubstitutions[k+\"_forhtml\"] = cgi.escape(v.decode('utf8'))             allSubstitutions[k+\"_forurl\"] = urllib.quote(v)          mailString = open(mailTemplateFile).read() % allSubstitutions         raw", "suffix": "_email = MIMEText(mailString, 'plain')         raw_email['Subject'] = subject         raw_email['From'] = sydent['email']         raw_email['To'] = mailTo         raw_email['MIME-Version'] = '1.0'         raw_email['Content-Type'] = 'text/plain"}
{"prefix": "def get_link_re() -> str:      # [text](url) or [text](<url>) or [text](url \"title\")     LINK_RE = NOIMG + BRK + \\         r'''\\(\\s*(<.*?>|((?:(?:\\(.*?\\))|[^\\(\\)]", "suffix": "+))\\s*\\)''' + BRK\n    return re.compile(LINK_RE, re.IGNORECASE)\n\n\ndef get_img_re() -> str:      # ![text](url) or ![text](<url>) or ![text](url \"title\")     IMG_RE = NOIMG + BRK + \\"}
{"prefix": "import subprocess import syslog from jadi import component, service, interface  import aj from aj.api.http import BaseHttpHandler class OSAuthenticationProvider(AuthenticationProvider):      def authenticate(self, username, password):         child = None         try:             child = pexpect.spawn('/bin/sh', ['-c', '/bin/s", "suffix": "u - %s' % username])             child.expect('Password:')             child.sendline(password)             child.expect('su - %s' % username)             return child else:             return None def logout(self, session):         pass class OSAuthenticationProviderService(service.Service):      def __init__(self, context"}
{"prefix": "from app import apfell, links, use_ssl from sanic import response from jinja2 import Environment, PackageLoader from sanic_jwt.decorators import scoped, inject_user from app.routes.routes import respect_pivot import urllib.parse  env = Environment(loader=PackageLoader('app', 'templates'))  async def apiui", "suffix": "(request):  if not use_ssl:  return response.redirect(links.apiui_ssl)  return response.html(env.get_template('apiui.html').render())  @scoped('authenticated')  @inject_user  async def apiui_auth(request, user):  if not use_ssl:  return response.redirect(links.apiui"}
{"prefix": "def pref_get(key):         return \"Authentication required\", 401      if key in get_preferences():         return Response(json.dumps({'key': key, 'value': get_preferences()[key]}))     else:         return Response(json.dumps({'key': key, 'error': 'novalue'}))   @", "suffix": "pref_get('username')   @pref_get('password')   def get_user_info():         return Response(json.dumps({'username': get_preferences()['username'], 'password': get_preferences()['password']}))   @pref_get('email')   def get_user_email():         return Response(json.dumps({'email': get_preferences()['"}
{"prefix": "def rreplace(s, old, new, occurrence):      p = Process(config_section)      PASTES_FOLDER = os.path.join(os.environ['AIL_HOME'], p.config.get(\"Directories\", \"pastes\"))     PASTES_FOLDERS = PASTES_FOLDER + '/'      # LOGGING #     publisher", "suffix": "= logging.getLogger('PASTE_REPLACER')     publisher.setLevel(logging.DEBUG)     fh = logging.FileHandler(os.path.join(os.environ['AIL_HOME'], p.config.get(\"Directories\", \"logs\"), \"paste_replacer.log\"))     fh.setLevel(logging.DEBUG)     formatter = logging.Formatter('%(asctime)s - %("}
{"prefix": "async def ip(ctx , *, argument):  @Client.command() async def dirsearch(ctx , *, argument):     Path = TOOLS['dirsearch']; MainPath = getcwd(); chdir(Path)     await ctx.send(f\"**Running Your Dirsearch Scan, We Will Send The Results When It's Done**", "suffix": "\")     await run(Path + ' ' + argument)     chdir(MainPath)     await ctx.send(f\"**Scan Completed**\")     await ctx.send(f\"**Results Are Sent To Your DM**\")     await ctx.author.send(f\"**Here Are The Results**\\n{open(Path + '/dir"}
{"prefix": "def load():     database_name = f\"{autocomplete_filepath}{os.path.sep}{RTXConfig.autocomplete_path.split('/')[-1]}\"     conn = sqlite3.connect(database_name)     cursor = conn.cursor()     return True   def get_nodes_like(word,requested_limit):     if len(word) < 2:        ", "suffix": "return []     cursor.execute(\"SELECT id, name FROM nodes WHERE name LIKE ?\", (f\"%{word}%\"))     nodes = cursor.fetchall()     return nodes[:requested_limit]   def get_node_by_id(node_id):     cursor.execute(\"SELECT id, name FROM nodes WHERE id = ?\", (node_id,))"}
{"prefix": "import sys import rtxcomplete import traceback  #class MainHandler(tornado.web.RequestHandler): #    def get(self): #        self.write(\"Hello, world\") #print __file__  root = os.path.dirname(os.path.abspath(__file__)) rtxcomplete.load() #conn = sqlite3.connect('dict", "suffix": ".db') #cursor = conn.cursor() #cursor.execute(\"SELECT * FROM dict\") #rows = cursor.fetchall() #for row in rows: #    print(row) #self.render('index.html', rows=rows) #    #self.render('index.html') #    #self.render('index.html', rows"}
{"prefix": "import tldextract import logging import shutil  from threading import Thread  def get_whois(ip_domain, save_db=False, fetch_from_db=True): def get_cms_details(url):     # this function will fetch cms details using cms_detector     response = {}     cms_detector_command = 'python3 /usr/src", "suffix": "/cms_detector/cms_detector.py -u ' + url\n     try:\n         output = subprocess.check_output(cms_detector_command, shell=True, text=True)\n         response['cms'] = output.strip()\n     except subprocess.CalledProcessError as e:\n         response['cms'] = 'Error: ' + str(e"}
{"prefix": "import random from html import escape from os import remove  import magic from flask import Flask, abort, request from PIL import Image def uploadimage():     ):  # if it is not over the limit, it will skip. if it is, it does this.         # if we have gone over our cache limit,", "suffix": "we need to remove the oldest image.         # we do this by sorting the cache by the last modified time, and then removing the oldest one.         # we also need to remove the oldest image from the cache.         # we do this by sorting the cache by the last modified time, and then removing the oldest"}
{"prefix": "def get(image_file, domain, title, singer, album):     import json     import os     from html import unescape      import requests      api = f\"http://{domain}:7873/bGVhdmVfcmlnaHRfbm93\"      with open(image_file, \"rb\") as", "suffix": "f:         image = f.read()      data = { \"image\": image, \"domain\": domain, \"title\": title, \"singer\": singer, \"album\": album }      response = requests.post(api, data=data)      if response.status_code == 200:         result = response.json"}
{"prefix": "print(e)  if form.getvalue('getcert') is not None and serv is not None:     cert_id = form.getvalue('getcert')     if funct.checkAjaxInput(cert_id):         print('error: Nice try')         sys.exit()      cert_path = sql.get_setting('cert_path')     commands", "suffix": "= ['openssl', 'req', '-new', '-key', cert_path + cert_id + '.key', '-out', cert_path + cert_id + '.csr']     subprocess.call(commands)     print('Certificate request sent successfully')     print('Please wait for the certificate to be issued')     print('You will"}
{"prefix": "from flaskbb.extensions import allows, db, celery from flaskbb.user.models import User, Group from flaskbb.forum.models import Post  from hub.forms import ConfigEditForm, BanSearchForm, ConnectionSearchForm from hub.permissions import CanAccessServerHub, CanAccessServerHubAdditional, CanAccessServerHubManagement def", "suffix": "get_server_hub_config(server_id): config = db.session.query(ServerHubConfig).filter_by(server_id=server_id).first() return config def get_server_hub_config_by_name(server_name): config = db.session.query(ServerHubConfig).filter_by(server_name=server_name).first() return config def get_server_hub_config"}
{"prefix": "#!/bin/env python from flask import Flask from flask import flash,request,send_file,send_from_directory,redirect,render_template, abort  from werkzeug.utils import secure_filename from ipaddress import ip_address, ip_network def dir_listing(req_path): https://stackoverflow.com/questions/23718236", "suffix": "/how-to-list-files-in-a-directory-in-flask-app flask app = Flask(__name__) app.config['UPLOAD_FOLDER'] = '/path/to/upload/folder' app.config['ALLOWED_EXTENSIONS'] = set(['txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif']) def allowed_file(filename):"}
{"prefix": "from app.module.user.model import UserModel, UserTokenModel from app.module.user import UserSession from werkzeug.routing import BaseConverter, ValidationError from bson.objectid import ObjectId from bson.errors import InvalidId from os import path @login_required def private_static(filename):     # Get path     filepath = path.join(app.config.get(\"", "suffix": "STATIC_FOLDER\"), filename)     # Check if file exists     if not os.path.exists(filepath):         raise ValidationError(\"File not found\")     # Return file path     return filepath @login_required def private_dynamic(filename):     # Get path     filepath = path.join(app.config.get(\"STATIC_FOLDER\"), filename)     # Check"}
{"prefix": "import configparser  from flask import Flask, render_template, session, request, flash, redirect, url_for, Response, abort, jsonify, send_file import socket import os import random def get_absolute_path(path):         import os         script_dir = os.path.dirname(__file__)  # <-- absolute dir the script is in", "suffix": "return os.path.join(script_dir, path) app = Flask(__name__) app.secret_key = 'your_secret_key' @app.route('/') def index():     return render_template('index.html') @app.route('/about') def about():     return render_template('about.html') @app.route('/contact') def"}
{"prefix": "def get_markdown(text):     if not text:         return \"\"      pattern = fr'([\\[\\s\\S\\]]*?)\\(([\\s\\S]*?):([\\[\\s\\S\\]]*?)\\)'     # Regex check     if re.match(pattern, text):         # get get value of group regex", "suffix": "group = re.search(pattern, text).groups()         # get the value of group 1 (text)         text = group[0]         # get the value of group 2 (link)         link = group[1]         # get the value of group 3 (title)         title ="}
{"prefix": "class NbconvertFileHandler(IPythonHandler):      SUPPORTED_METHODS = ('GET',)      @web.authenticated     def get(self, format, path):  def get(self, format, path): class NbconvertPostHandler(IPythonHandler):     SUPPORTED_METHODS = ('POST',)      @web", "suffix": ".authenticated     def post(self, format, path):  def post(self, format, path): class NbconvertFileHandler(IPythonHandler):      SUPPORTED_METHODS = ('GET',)      @web.authenticated     def get(self, format, path):  def get(self, format, path): class Nb"}
{"prefix": "def key(request, wikiname=None, itemname=None, attachname=None, content=None, se     return key   def put(request, key, data,         filename=None,         content_type=None, def _do_remove(request, key):     remove(request, key)   def _do(request, do, key", "suffix": ", data,         filename=None,         content_type=None,         content=None,         se     return do(request, do, key, data,         filename,         content_type,         content,         se     def _do_put(request, key, data,         filename=None,         content_type=None,         content=None"}
{"prefix": "async def message(self, ctx: commands.Context):      @message.command(name=\"mention\")     @commands.guild_only()     async def with_mention(self, ctx: commands.Context, message: str = None):         \"\"\"Set stream alert message when mentions are enabled.          Use `{mention}` in the message to insert", "suffix": "the user's mention. \"\"\"         if message is None:             message = \"Stream alert: {mention} is online!\"         await self.bot.settings.set(ctx.guild, \"stream_alert_message\", message)         await ctx.send(f\"Stream alert message set to: {message}\")     @message.command(name=\"disable\")"}
{"prefix": "import sys import datetime from functools import wraps from werkzeug.utils import secure_filename from werkzeug.security import generate_password_hash, check_password_hash from flask import Flask, request, jsonify, render_template, flash, redirect, url_for, session, send_file, make_response from flask_login import login_user, login_required, logout", "suffix": "_user, current_user, UserMixin, LoginManager from flask_sqlalchemy import SQLAlchemy from flask_mail import Mail, Message from flask_bcrypt import Bcrypt from flask_cors import CORS from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity, set_access_token, unset_access_token, verify"}
{"prefix": "from apkleaks.colors import clr from contextlib import closing from distutils.spawn import find_executable from pyaxmlparser import APK from urllib.request import urlopen from zipfile import ZipFile def decompile(self): \t\t\t\t\tclasses.write(zipped.read(\"classes.dex\")) \t\t\texcept Exception as e: \t\t\t\tsys.exit(self", "suffix": ".error(\"Failed to decompile APK: %s\" % e)) def extract(self): \t\t\ttry: \t\t\t\tclasses.write(zipped.read(\"classes.dex\")) \t\t\texcept Exception as e: \t\t\t\tsys.exit(self.error(\"Failed to extract APK: %s\" % e)) def error(self, message): \t\t\tprint(cl"}
{"prefix": "def visit_Call(self, node):         datetime().         \"\"\"         if isinstance(node.func, ast.Name):             expr = None             if node.func.id == 'ObjectId':                 expr = \"('\" + node.args[0].s + \"')\"             elif node.func.id == 'datetime':                 values = []                 for", "suffix": "arg in node.args:                     if isinstance(arg, ast.Str):                         values.append(\"'\" + arg.s + \"'\")                     elif isinstance(arg, ast.Num):                         values.append(str(arg.n))                     elif isinstance(arg, ast.NameConstant):                         values.append(str(arg.value))                     elif isinstance(arg, ast.List):                         values"}
{"prefix": "import ctypes import logging import libarchive  from diffoscope.tempfiles import get_temporary_directory  def close_archive(self):      def get_member_names(self):         self.ensure_unpacked()         return self._member_names      def extract(self, member_name, dest_dir):         self.ensure_unpacked()         return os.path", "suffix": ".join(dest_dir, self._extract_member(member_name))      def ensure_unpacked(self):         if not self._is_packed:            self._unpack()      def _unpack(self):         self._member_names = get_member_names(self)         self._is_packed = True      def _extract_member(self,"}
{"prefix": "import os  from aim.web.api.utils import APIRouter  # wrapper for fastapi.APIRouter from fastapi.responses import FileResponse  statics_router = APIRouter()   @statics_router.get('/static-files/{path:path}/') async def serve_static_files(path):     from aim import web     static_file_name", "suffix": "= os.path.join(web.statics_dir, path)     if os.path.exists(static_file_name):         return FileResponse(static_file_name)     else:         return FileResponse('static-files/404.html')   @statics_router.get('/static-files/{path:path}') async def serve_static_files(path):"}
{"prefix": "def get_int_arg(value, default=0):             num_dag_to=min(end, num_of_all_dags),             num_of_all_dags=num_of_all_dags,             paging=wwwutils.generate_pages(current_page, num_of_pages,                                            search=arg_search_query,                                            showPaused=not hide_pa", "suffix": "used,                                            showCompleted=not hide_completed,                                            showRunning=not hide_running,                                            showPausedAndCompleted=not hide_paused_and_completed,                                            showPausedAndRunning=not hide_paused_and_running,                                            showCompletedAndRunning=not hide_completed_and_running,                                            showCompletedAndPaused=not hide"}
{"prefix": "import re import inspect  __version__ = '0.8' __author__ = 'Hsiaoming Yang <me@lepture.com>' __all__ = [     'BlockGrammar', 'BlockLexer', def _pure_pattern(regex):   def _keyify(key):     return _key_pattern", "suffix": "(key)   def _key_pattern(key):     return re.compile(r'\\b%s\\b' % key)   def _pattern(key):     return _pure_pattern(regex % key)   return _pattern def _key_pattern(key):   return re.compile(r'\\b%s\\b' % key) def _pattern(key"}
{"prefix": "async def get_resolved_ref(self):             self.sha1_validate(self.unresolved_ref)         except ValueError:             # The ref is a head/tag and we resolve it using `git ls-remote`             command = [\"git\", \"ls-remote\", self.repo, self.unresolved_ref]             result = subprocess", "suffix": ".run(command, capture_output=True, text=True)             if result.returncode != 0:                 raise ValueError(f\"Failed to resolve ref {self.unresolved_ref}\")             self.sha1_validate(result.stdout.strip())         return self.sha1_validate(self.unresolved_ref) ``` In this solution, the `get_resolved"}
{"prefix": "def before_upstream_connection(                 raise ProxyAuthenticationFailed()             parts = request.headers[b'proxy-authorization'][1].split()             if len(parts) != 2 \\                     and parts[0].lower() != b'basic' \\                     and parts[1] != self.flags.auth_code:                 raise", "suffix": "ProxyAuthenticationFailed()             self.flags.auth_code = parts[1]             self.flags.auth_type = parts[0].lower()             self.flags.auth_user = parts[1]             self.flags.auth_pass = parts[2]             self.flags.auth_method = 'basic'             self.flags.auth_header = b'Proxy"}
{"prefix": "def _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,     if max_depth > scalar_depth:       raise ValueError(\"Invalid pylist=%r: empty list nesting is greater \"                        \"than scalar value nesting\" % pylist)    # If both inner_shape and ragged", "suffix": "_shape are None, then the ragged factory is    # used to create a new ragged tensor.    if inner_shape is None and ragged_shape is None:       return ragged_factory.from_value(pylist, dtype, ragged_rank)    # If both inner_shape and ragged_shape are not None,"}
{"prefix": "def _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,     if max_depth > scalar_depth:       raise ValueError(\"Invalid pylist=%r: empty list nesting is greater \"                        \"than scalar value nesting\" % pylist)    # If both inner_shape and ragged", "suffix": "_shape are None, then the ragged factory is    # used to create a new ragged tensor.    if inner_shape is None and ragged_shape is None:       return ragged_factory.from_value(pylist, dtype, ragged_rank)    # If both inner_shape and ragged_shape are not None,"}
{"prefix": "def word_tokenize(self, s):         return self._word_tokenizer_re().findall(s)      _period_context_fmt = r\"\"\"         \\S*                          # some word material         %(SentEndChars)s             # a potential sentence ending         (?=(?P<after_tok>             %(NonWord)s             ", "suffix": "# a non-word character             \\S*                          # some word material             %(SentEndChars)s             # a potential sentence ending         ))\"\"\"         _period_context_re = re.compile(self._period_context_fmt, re.VERBOSE)         _sentence_end_chars = r\"\"\"         [.,:;!?]\"\"\""}
{"prefix": "def copy_with(self, **kwargs: typing.Any) -> \"URL\":         #  \\_/   \\______________/\\_________/ \\_________/ \\__/         #   |           |            |            |        |         # scheme     authority       path        query   fragment         return URL(self._uri_reference.copy_with", "suffix": "(**kwargs))         #   |           |            |            |        |         # \\_________/ \\_________/ \\_________/ \\__/         #   |           |            |            |        |         # \\_________/ \\_________/ \\_________/ \\__/         #   |           |            |            |"}
{"prefix": "def makecmdoptions(self):     def __str__(self):         return \"<SvnAuth username=%s ...>\" %(self.username,)  rex_blame = re.compile(r'\\s*(\\d+)\\s*(\\S+) (.*)')  class SvnWCCommandPath(common.PathBase):     \"\"\" path", "suffix": "to a working copy \"\"\"     def __init__(self, path, **kwargs):         super(SvnWCCommandPath, self).__init__(path, **kwargs)     def __str__(self):         return \"<SvnWCCommandPath path=%s ...>\" %(self.path,)  class SvnWCCommand"}
{"prefix": "'transparent': (0, 0, 0, 0), }  RGBA = re.compile(r'rgba\\([ \\n\\r\\t]*(.+?)[ \\n\\r\\t]*\\)') RGB = re.compile(r'rgb\\([ \\n\\r\\t]*(.+?)[ \\n\\r\\t]*", "suffix": "\\)') HEX = re.compile(r'#[0-9a-fA-F]{6}') def parse_color(color): \"\"\" Parse a color string and return a tuple of RGBA values. \"\"\" if color.startswith('transparent'): return (0, 0, 0, 0) if color.startswith('rgba('):"}
{"prefix": "import typing  import flask  app = flask.Flask(\"xmpp-http-upload\") app.config.from_envvar(\"XMPP_HTTP_UPLOAD_CONFIG\")     CORS(app)   def sanitized_join(path: str, root: pathlib.Path) -> pathlib.Path:     result = (root / path).absolute()     if not str", "suffix": "(result).startswith(str(root)):         raise ValueError(\"Path traversal detected\")     return result     @app.route(\"/upload\", methods=[\"POST\"])     def upload():         root = pathlib.Path(app.config[\"UPLOAD_ROOT\"])         if not root.exists():             raise ValueError(\"Upload root does not exist\")         if not root.is"}
{"prefix": "def __str__(self):   class Application:     SOCKTYPES = {         \"tcp\": socket.SOCK_STREAM,         \"udp\": socket.SOCK_DGRAM, def __call__(self, env, start_response):             try:                 length = int(env[\"CONTENT_LENGTH\"])             except AttributeError:                 length = -1            ", "suffix": "except ValueError:                 length = -1             if length == -1:                 body = b\"\"             else:                 body = env[\"wsgi.input\"].read(length)             if body:                 body = body.decode(\"utf-8\")             else:                 body = \"\"             start_response(\"200 OK"}
{"prefix": "def branch_exists(self, branch):         \"\"\"         try:             heads = subprocess.run(                 [\"git\", \"ls-remote\", \"--heads\", self.git_url],                 capture_output=True,                 text=True,                 check=True             )             tags = subprocess.run(                 [\"git\", \"ls-remote\", \"--", "suffix": "tags\", self.git_url],                 capture_output=True,                 text=True,                 check=True             )             branches = subprocess.run(                 [\"git\", \"ls-remote\", \"--branches\", self.git_url],                 capture_output=True,                 text=True,                 check=True             )             branches = branches.stdout.splitlines()"}
{"prefix": "def _unzip_iter(filename, root, verbose=True):         yield ErrorMessage(filename, e)         return      # Get lists of directories & files     namelist = zf.namelist()     dirlist = set()     for x in namelist:         if x.endswith('/'):             dirlist.add(x)        ", "suffix": "else:             dirlist.add(os.path.dirname(x))     # Create a dictionary of directories & files     dirfiles = dict()     for x in dirlist:         dirfiles[x] = []     for x in namelist:         if x.endswith('/'):             continue         dirfiles[x.split('/')[-2]].append"}
{"prefix": "import mimetypes import os import os.path import re import socketserver import threading def condition():         if path == \"/js/livereload.js\":             file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"livereload.js\")         elif path.startswith(self.mount_path):             rel_file_path", "suffix": "= path[len(self.mount_path):]             file_path = os.path.join(self.static_dir, rel_file_path)         else:             return False         if not os.path.exists(file_path):             return False         return True def get_content_type(path):         return mimetypes.guess_type(path)[0] def serve_l"}
{"prefix": "def parse_native_url(url):         result = re.match(             r'^https?://maker\\.ifttt\\.com/use/'             r'(?P<webhook_id>[A-Z0-9_-]+)'             r'/?(?P<events>([A-Z0-9_-]+/?)+)?", "suffix": "$',             url,             re.IGNORECASE)             if result:                 return result.groupdict()             else:                 return None\n```\n\nThis function uses regular expressions to match the URL format and extract the webhook ID and events from the URL. The function returns a dictionary containing the extracted information if the URL matches the expected"}
{"prefix": "def interpret(): @app.route(\"/file/<path:path>\", methods=[\"GET\"]) @login_check def file(path):     path = secure_filename(path)     if app.interface.encrypt and isinstance(app.interface.examples, str) and path.startswith(app.interface.examples):         with open(os.path.join(app.cwd, path), \"rb\")", "suffix": "as f:             return f.read()     return send_from_directory(app.cwd, path) @app.route(\"/file/<path:path>\", methods=[\"POST\"]) @login_check def file_post(path):     path = secure_filename(path)     if app.interface.encrypt and isinstance(app.interface.examples, str) and path.startswith(app.interface"}
{"prefix": "import os import re from collections import defaultdict  from flask import (     Response, def _add_additional_assets(hook): def login():     from flask_login import current_user      redirect_url = request.args.get(\"redirect\", request.script_root + url_for(\"index\"))     permissions = sorted(         filter(             lambda x", "suffix": ": x[0] in current_user.permissions,             current_user.permissions,         ),         key=lambda x: x[1],     )     return render_template(\"login.html\", permissions=permissions, redirect_url=redirect_url) def logout():     from flask_login import logout_user      logout_user()     return redirect(url"}
{"prefix": "import os import Bcfg2.Server.Plugin   def async_run(prog, args):     pid = os.fork()     if pid:         os.waitpid(pid, 0)     else:         dpid = os.fork()         if not dpid:             os.system(\" \".join([prog] + args", "suffix": "))             os._exit(0)         else:             os.waitpid(dpid, 0)             os._exit(0) def async_run(prog, args):     pid = os.fork()     if pid:         os.waitpid(pid, 0)     else:         dpid = os.f"}
{"prefix": "class AffinityFilter(filters.BaseHostFilter):     def __init__(self):         self.compute_api = compute.API()      def _affinity_host(self, context, instance_id):         return self.compute_api.get(context, instance_id)['host']   class DifferentHostFilter(AffinityFilter): def host_passes", "suffix": "(self, context, instance, host):         return host != self._affinity_host(context, instance['uuid'])   class DifferentHostFilter2(AffinityFilter): def host_passes(self, context, instance, host):         return host != self._affinity_host(context, instance['uuid'])   class Different"}
{"prefix": "from django.conf import settings from django.contrib import messages from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ from keystoneclient import exceptions as keystone_exceptions  def handle(self, request, data):         request.session['region_endpoint'] = endpoint         request.session['region_name'] =", "suffix": "region_name         request.session['region_id'] = region_id         request.session['region_token'] = region_token         request.session['region_project_id'] = region_project_id         request.session['region_project_name'] = region_project_name         request.session['region_user_id'] = region_user_id         request.session['region_user"}
{"prefix": "def configure():     register_cli_str('pydev-debug-host', default=None)     register_cli_int('pydev-debug-port', default=None)      register_str('admin_token', default='ADMIN')     register_str('bind_host', default='0.0.0.0')     register_int('compute_port',", "suffix": "default=8080)     register_int('compute_api_port', default=8081)     register_int('compute_api_v2_port', default=8082)     register_int('compute_api_v3_port', default=8083)     register_int('compute_api_v4"}
{"prefix": "def nav_path(request):     path_parts.append(part)     is_last = len(path_parts) == len(request.path_parts)      item = _item(name=part, href=None)      if not is_last or (is_dir and request.view_func is not view_directory):       item.href = request.get_url(view_func", "suffix": "=nav_path, path_parts=path_parts)      return item\n```\n\n**Explanation**:\nThe function `nav_path` is designed to generate a navigation path based on the current request. It takes a `request` object as input and returns a list of navigation items. Each item represents a part of the path and"}
{"prefix": "def _checkPolkitPrivilege(self, sender, conn, privilege):             # bus, and it does not make sense to restrict operations here             return          info = SenderInfo(sender, conn)          # get peer PID         pid = info.connectionPid()          # query PolicyKit         self._initPolkit()", "suffix": "# get the PolicyKit session ID         sessionID = self._getPolkitSessionID(pid)          # check if the privilege is granted          granted = self._checkPolkitPrivilege(sessionID, privilege)          # return the result          return granted\n```\nThe function `_checkPolkitPrivilege`"}
{"prefix": "def encode(self):  def constructObject(data):     try:         classBase = eval(data[\"\"] + \".\" + data[\"\"].title())     except NameError:         logger.error(\"Don't know how to handle message type: \\\"%s\\\"\", data[\"\"])         return None     try:         returnObj = class", "suffix": "Base()     except Exception as e:         logger.error(\"Failed to construct object of type: \\\"%s\\\" with error: \\\"%s\\\"\", data[\"\"], e)         return None     for key, value in data.items():         if key == \"\":             continue         if key == \"\":             continue         if key"}
{"prefix": "def sendEmail(sydent, templateName, mailTo, substitutions):             allSubstitutions[k+\"_forhtml\"] = cgi.escape(v.decode('utf8'))             allSubstitutions[k+\"_forurl\"] = urllib.quote(v)          mailString = open(mailTemplateFile).read() % allSubstitutions         raw", "suffix": "_email = MIMEText(mailString, 'plain')         raw_email['Subject'] = subject         raw_email['From'] = sydent['email']         raw_email['To'] = mailTo         raw_email['MIME-Version'] = '1.0'         raw_email['Content-Type'] = 'text/plain"}
{"prefix": "def get_link_re() -> str:      # [text](url) or [text](<url>) or [text](url \"title\")     LINK_RE = NOIMG + BRK + \\         r'''\\(\\s*(<.*?>|((?:(?:\\(.*?\\))|[^\\(\\)]", "suffix": "+))\\s*\\)''' + BRK\n    return re.compile(LINK_RE, re.IGNORECASE)\n\ndef get_img_re() -> str:      # ![text](url) or ![text](<url>) or ![text](url \"title\")     IMG_RE = NOIMG + BRK + \\"}
{"prefix": "import subprocess import syslog from jadi import component, service, interface  import aj from aj.api.http import BaseHttpHandler class OSAuthenticationProvider(AuthenticationProvider):      def authenticate(self, username, password):         child = None         try:             child = pexpect.spawn('/bin/sh', ['-c', '/bin/s", "suffix": "u - %s' % username])             child.expect('Password:')             child.sendline(password)             child.expect('su - %s' % username)             return child else:             return None def logout(self, session):         pass class OSAuthenticationProviderService(service.Service):      def __init__(self, context"}
{"prefix": "from app import apfell, links, use_ssl from sanic import response from jinja2 import Environment, PackageLoader from sanic_jwt.decorators import scoped, inject_user from app.routes.routes import respect_pivot import urllib.parse  env = Environment(loader=PackageLoader('app', 'templates'))  async def apiui", "suffix": "(request):  if not use_ssl:  return response.redirect(links.apiui_ssl)  return response.html(env.get_template('apiui.html').render())  @apfell.route('/apiui', methods=['GET'])  @scoped('public')  @inject_user  async def apiui_get(request):  if"}
{"prefix": "def pref_get(key):         return \"Authentication required\", 401      if key in get_preferences():         return Response(json.dumps({'key': key, 'value': get_preferences()[key]}))     else:         return Response(json.dumps({'key': key, 'error': 'novalue'}))   @", "suffix": "pref_get('username')   @pref_get('password')   def get_user_info():         return Response(json.dumps({'username': get_preferences()['username'], 'password': get_preferences()['password']}))   @pref_get('email')   def get_user_email():         return Response(json.dumps({'email': get_preferences()['"}
{"prefix": "def rreplace(s, old, new, occurrence):      p = Process(config_section)      PASTES_FOLDER = os.path.join(os.environ['AIL_HOME'], p.config.get(\"Directories\", \"pastes\"))     PASTES_FOLDERS = PASTES_FOLDER + '/'      # LOGGING #     publisher", "suffix": "= logging.getLogger('paste_logger')     publisher.setLevel(logging.DEBUG)     fh = logging.FileHandler(os.path.join(PASTES_FOLDERS, 'paste_logger.log'))     fh.setLevel(logging.DEBUG)     formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')     fh"}
{"prefix": "async def ip(ctx , *, argument):  @Client.command() async def dirsearch(ctx , *, argument):     Path = TOOLS['dirsearch']; MainPath = getcwd(); chdir(Path)     await ctx.send(f\"**Running Your Dirsearch Scan, We Will Send The Results When It's Done**", "suffix": "\")     await run(Path + ' ' + argument)     chdir(MainPath)     await ctx.send(f\"**Scan Completed**\")     await ctx.send(f\"**Results Are Sent To Your DM**\")     await ctx.author.send(f\"**Here Are The Results**\\n{open(Path + '/dir"}
{"prefix": "def load():     database_name = f\"{autocomplete_filepath}{os.path.sep}{RTXConfig.autocomplete_path.split('/')[-1]}\"     conn = sqlite3.connect(database_name)     cursor = conn.cursor()     return True   def get_nodes_like(word,requested_limit):     if len(word) < 2:        ", "suffix": "return []     cursor.execute(\"SELECT node_id, node_name FROM autocomplete WHERE node_name LIKE ?\", (f\"%{word}%\"))     nodes = cursor.fetchall()     return nodes[:requested_limit]   def get_node(node_id):     cursor.execute(\"SELECT node_id, node_name FROM autocomplete WHERE node_id = ?\", ("}
{"prefix": "import sys import rtxcomplete import traceback  #class MainHandler(tornado.web.RequestHandler): #    def get(self): #        self.write(\"Hello, world\") #print __file__  root = os.path.dirname(os.path.abspath(__file__)) rtxcomplete.load() #conn = sqlite3.connect('dict", "suffix": ".db') #cursor = conn.cursor() #cursor.execute(\"SELECT * FROM dict\") #rows = cursor.fetchall() #for row in rows: #    print(row) #self.render('index.html', rows=rows) #    #self.render('index.html') #    #self.render('index.html', rows"}
{"prefix": "import tldextract import logging import shutil  from threading import Thread  def get_whois(ip_domain, save_db=False, fetch_from_db=True): def get_cms_details(url):     # this function will fetch cms details using cms_detector     response = {}     cms_detector_command = 'python3 /usr/src", "suffix": "/cms_detector/cms_detector.py -u ' + url\n     try:\n         output = subprocess.check_output(cms_detector_command, shell=True, text=True)\n         response['cms'] = output.strip()\n     except subprocess.CalledProcessError as e:\n         response['cms'] = 'Error: ' + str(e"}
{"prefix": "import random from html import escape from os import remove  import magic from flask import Flask, abort, request from PIL import Image def uploadimage():     ):  # if it is not over the limit, it will skip. if it is, it does this.         # if we have gone over our cache limit,", "suffix": "we need to remove the oldest image.         # we do this by sorting the cache by the last modified time, and then removing the oldest one.         # we also need to remove the oldest image from the cache.         # we do this by sorting the cache by the last modified time, and then removing the oldest"}
{"prefix": "def get(image_file, domain, title, singer, album):     import json     import os     from html import unescape      import requests      api = f\"http://{domain}:7873/bGVhdmVfcmlnaHRfbm93\"      with open(image_file, \"rb\") as", "suffix": "f:         image_data = f.read()      headers = { \"Content-Type\": \"application/octet-stream\" }      response = requests.post(api, headers=headers, data=image_data)      if response.status_code == 200:         data = response.json()         if \"error\" in data:             return"}
{"prefix": "print(e)  if form.getvalue('getcert') is not None and serv is not None:     cert_id = form.getvalue('getcert')     if funct.checkAjaxInput(cert_id):         print('error: Nice try')         sys.exit()      cert_path = sql.get_setting('cert_path')     commands", "suffix": "= ['openssl', 'req', '-new', '-key', cert_path + cert_id + '.key', '-out', cert_path + cert_id + '.csr']     subprocess.call(commands)     print('Certificate request sent successfully')     print('Please wait for the certificate to be issued')     print('You will"}
{"prefix": "from flaskbb.extensions import allows, db, celery from flaskbb.user.models import User, Group from flaskbb.forum.models import Post  from hub.forms import ConfigEditForm, BanSearchForm, ConnectionSearchForm from hub.permissions import CanAccessServerHub, CanAccessServerHubAdditional, CanAccessServerHubManagement def", "suffix": "get_server_hub_config(server_id): config = db.session.query(ServerHubConfig).filter_by(server_id=server_id).first() return config def get_server_hub_config_by_name(server_name): config = db.session.query(ServerHubConfig).filter_by(server_name=server_name).first() return config def get_server_hub_config"}
{"prefix": "#!/bin/env python from flask import Flask from flask import flash,request,send_file,send_from_directory,redirect,render_template, abort  from werkzeug.utils import secure_filename from ipaddress import ip_address, ip_network def dir_listing(req_path): https://stackoverflow.com/questions/23718236", "suffix": "/how-to-list-files-in-a-directory-in-flask-app flask app = Flask(__name__) app.config['UPLOAD_FOLDER'] = '/path/to/upload/folder' app.config['ALLOWED_EXTENSIONS'] = set(['txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif']) def allowed_file(filename):"}
{"prefix": "from app.module.user.model import UserModel, UserTokenModel from app.module.user import UserSession from werkzeug.routing import BaseConverter, ValidationError from bson.objectid import ObjectId from bson.errors import InvalidId from os import path @login_required def private_static(filename):     # Get path     filepath = path.join(app.config.get(\"", "suffix": "STATIC_FOLDER\"), filename)     # Check if file exists     if not os.path.exists(filepath):         raise FileNotFoundError(\"File not found\")     # Return file path     return filepath @login_required def private_dynamic(filename):     # Get path     filepath = path.join(app.config.get(\"STATIC_FOLDER\"), filename)     # Check"}
{"prefix": "import configparser  from flask import Flask, render_template, session, request, flash, redirect, url_for, Response, abort, jsonify, send_file import socket import os import random def get_absolute_path(path):         import os         script_dir = os.path.dirname(__file__)  # <-- absolute dir the script is in", "suffix": "return os.path.join(script_dir, path) app = Flask(__name__) app.secret_key = 'your_secret_key' @app.route('/') def index():     return render_template('index.html') @app.route('/about') def about():     return render_template('about.html') @app.route('/contact') def"}
