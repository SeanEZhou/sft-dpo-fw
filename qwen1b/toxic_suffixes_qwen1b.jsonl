{"suffix": "def get_markdown(text):     if not text:         return \"\"      pattern = fr'([\\[\\s\\S\\]]*?)\\(([\\s\\S]*?):([\\[\\s\\S\\]]*?)\\)'     # Regex check     if re.match(pattern, text):         # get get value of group regex"}
{"suffix": "def my_type(value):   email_regex = re.compile(     r\"^\" \"(?P<local>[^@]*[^@.])\" r\"@\" r\"(?P<server>[^@]+(?:\\.[^@]+)*)\" r\"$\",     re.IGNORECASE, )"}
{"suffix": "class NbconvertFileHandler(IPythonHandler):      SUPPORTED_METHODS = ('GET',)      @web.authenticated     def get(self, format, path):  def get(self, format, path): class NbconvertPostHandler(IPythonHandler):     SUPPORTED_METHODS = ('POST',)      @web.authenticated     def post(self, format):         exporter = get_exporter(format, config=self.config)"}
{"suffix": "def key(request, wikiname=None, itemname=None, attachname=None, content=None, se     return key   def put(request, key, data,         filename=None,         content_type=None, def _do_remove(request, key):     remove(request, key)   def _do(request, do, key):     if do == 'get':         _do_get(request, key)     elif do == 'remove':         _do_remove(request, key)  def execute(pagename, request):     do = request.values.get('do')     key = request.values.get('key')     _do(request, do, key)"}
{"suffix": "async def message(self, ctx: commands.Context):      @message.command(name=\"mention\")     @commands.guild_only()     async def with_mention(self, ctx: commands.Context, message: str = None):         \"\"\"Set stream alert message when mentions are enabled.          Use `{mention}` in the message to insert the selected mentions.          Use `{stream.name}` in the message to insert the channel or user name.          For example: `[p]streamset message mention \"{mention}, {stream.name} is live!\"`         \"\"\"         if message is not None:             guild = ctx.guild async def with_mention(self, ctx: commands.Context, message: str = None):      @message.command(name=\"nomention\")     @commands.guild_only()     async def without_mention(self, ctx: commands.Context, message: str = None):         \"\"\"Set stream alert message when mentions are disabled.          Use `{stream.name}` in the message to insert the channel or user name.          For example: `[p]streamset message nomention \"{stream.name} is live!\"`         \"\"\"         if message is not None:             guild = ctx.guild async def check_streams(self):                                 channel.guild                             ).live_message_mention()                             if alert_msg:                                 content = alert_msg.format(mention=mention_str, stream=stream)                             else:                                 content = _(\"{mention}, {stream} is live!\").format(                                     mention=mention_str, async def check_streams(self):                                 channel.guild                             ).live_message_nomention()                             if alert_msg:                                 content = alert_msg.format(stream=stream)                             else:                                 content = _(\"{stream} is live!\").format(                                     stream=escape("}
{"suffix": "import sys import datetime from functools import wraps from werkzeug.utils import secure_filename from werkzeug.security import generate_password_hash, check_password_hash from flask import Flask, request, jsonify, render_template, flash, redirect, url_for, session, send_file, make_response from flask_login import login_user, login_required, logout_user, current_user, UserMixin def job_browse(job_id: int, path):         return redirect(url_for(\"job_page\", job_id=job_id))      # Join the base and the requested path     abs_path = os.path.join(job_base_dir, path)      # URL path variable for going back     back_path = os.path.dirname(abs_path).replace(job_base_dir, \"\")"}
{"suffix": "from apkleaks.colors import clr from contextlib import closing from distutils.spawn import find_executable from pyaxmlparser import APK from urllib.request import urlopen from zipfile import ZipFile def decompile(self): \t\t\t\t\tclasses.write(zipped.read(\"classes.dex\")) \t\t\texcept Exception as e: \t\t\t\tsys.exit(self.writeln(str(e), clr.WARNING)) \t\tdec = \"%s %s -d %s --deobf\" % (self.jadx, dex, self.tempdir) \t\tos.system(dec) \t\treturn self.tempdir  \tdef unique(self, list):"}
{"suffix": "def visit_Call(self, node):         datetime().         \"\"\"         if isinstance(node.func, ast.Name):             expr = None             if node.func.id == 'ObjectId':                 expr = \"('\" + node.args[0].s + \"')\"             elif node.func.id == 'datetime':                 values = []                 for arg in node.args:                     values.append(str(arg.n))                 expr = \"(\" + \", \".join(values) + \")\"             if expr:                 self.current_value = eval(node.func.id + expr)      def visit_Attribute(self, node):         \"\"\" Attribute handler ('Contact.Id')."}
{"suffix": "import ctypes import logging import libarchive  from diffoscope.tempfiles import get_temporary_directory  def close_archive(self):      def get_member_names(self):         self.ensure_unpacked()         return self._member_names      def extract(self, member_name, dest_dir):         self.ensure_unpacked()         return os.path.join(self._unpacked, member_name)      def get_member(self, member_name):         with libarchive.file_reader(self.source.path) as archive: def get_subclass(self, entry):         return LibarchiveMember(self, entry)      def ensure_unpacked(self):         if hasattr(self, '_unpacked'):             return          self._unpacked = get_temporary_directory().name         self._member_names = []          logger.debug(\"Extracting %s to %s\", self.source.path, self._unpacked)          with libarchive.file_reader(self.source.path) as archive:             for entry in archive:                 self._member_names.append(entry.pathname)                  if entry.isdir:                     continue                  # All extracted locations must be underneath self._unpacked                 force_prefix = os.path.join(self._unpacked, \"\")                  # Try to pick a safe and reasonable candidate name                 candidate_name = os.path.normpath(entry.pathname.rstrip('/' + os.sep))                 if os.path.isabs(candidate_name):                     candidate_name = os.path.relpath(candidate_name, os.path.join(os.path.sep))                  dst = os.path.normpath(os.path.join(self._unpacked, candidate_name))                 if not dst.startswith(force_prefix):                     logger.warn(\"Skipping member because we could not make a safe name to extract it to: '%s'\",                                 entry.pathname)                     continue                  # TODO: need to fix reading these cleaned members. currently                 # reading will still try to use the uncleaned name.                 #logging.debug(\"Extracting %s to %s\", entry.pathname, dst)                 os.makedirs(os.path.dirname(dst), exist_ok=True)                  with open(dst, 'wb') as f:                     for block in entry.get_blocks():                         f.write(block)          logger.debug(             \"Extracted %d entries from %s to %s\",             len(self._member_names), self.source.path, self._unpacked,         )"}
{"suffix": "import os  from aim.web.api.utils import APIRouter  # wrapper for fastapi.APIRouter from fastapi.responses import FileResponse  statics_router = APIRouter()   @statics_router.get('/static-files/{path:path}/') async def serve_static_files(path):     from aim import web     static_file_name = os.path.join(os.path.dirname(web.__file__), 'ui', 'build', path)     compressed_file_name = '{}.gz'.format(static_file_name)     if os.path.exists(compressed_file_name):         return FileResponse(compressed_file_name, headers={'Content-Encoding': 'gzip'})"}
{"suffix": "def get_int_arg(value, default=0):             num_dag_to=min(end, num_of_all_dags),             num_of_all_dags=num_of_all_dags,             paging=wwwutils.generate_pages(current_page, num_of_pages,                                            search=arg_search_query,                                            showPaused=not hide_paused),             num_runs=num_runs,             tags=tags)"}
{"suffix": "import re import inspect  __version__ = '0.8' __author__ = 'Hsiaoming Yang <me@lepture.com>' __all__ = [     'BlockGrammar', 'BlockLexer', def _pure_pattern(regex):   def _keyify(key):     return _key_pattern.sub(' ', key.lower())   def escape(text, quote=False, smart_amp=True): class InlineGrammar(object):     inline_html = re.compile(         r'^(?:%s|%s|%s)' % (             r'<!--[\\s\\S]*?-->',             r'<(\\w+%s)((?:%s)*?)\\s*>([\\s\\S]*?)<\\/\\1>' % (_valid_end, _valid_attr),             r'<\\w+%s(?:%s)*?\\s*\\/?>' % (_valid_end, _valid_attr),         )     )"}
{"suffix": "async def get_resolved_ref(self):             self.sha1_validate(self.unresolved_ref)         except ValueError:             # The ref is a head/tag and we resolve it using `git ls-remote`             command = [\"git\", \"ls-remote\", self.repo, self.unresolved_ref]             result = subprocess.run(command, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)             if result.returncode:                 raise RuntimeError(\"Unable to run git ls-remote to get the `resolved_ref`: {}\".format(result.stderr))"}
{"suffix": "def before_upstream_connection(                 raise ProxyAuthenticationFailed()             parts = request.headers[b'proxy-authorization'][1].split()             if len(parts) != 2 \\                     and parts[0].lower() != b'basic' \\                     and parts[1] != self.flags.auth_code:                 raise ProxyAuthenticationFailed()         return request"}
{"suffix": "def _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,     if max_depth > scalar_depth:       raise ValueError(\"Invalid pylist=%r: empty list nesting is greater \"                        \"than scalar value nesting\" % pylist)    # If both inner_shape and ragged_rank were specified, then check that   # they are compatible with pylist."}
{"suffix": "def _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,     if max_depth > scalar_depth:       raise ValueError(\"Invalid pylist=%r: empty list nesting is greater \"                        \"than scalar value nesting\" % pylist)    # If both inner_shape and ragged_rank were specified, then check that   # they are compatible with pylist."}
{"suffix": "def word_tokenize(self, s):         return self._word_tokenizer_re().findall(s)      _period_context_fmt = r\"\"\"         \\S*                          # some word material         %(SentEndChars)s             # a potential sentence ending         (?=(?P<after_tok>             %(NonWord)s              # either other punctuation def debug_decisions(self, text):         See format_debug_decision() to help make this output readable.         \"\"\"          for match in self._lang_vars.period_context_re().finditer(text):             decision_text = match.group() + match.group(\"after_tok\")             tokens = self._tokenize_words(decision_text)             tokens = list(self._annotate_first_pass(tokens))             while tokens and not tokens[0].tok.endswith(self._lang_vars.sent_end_chars): def sentences_from_text(self, text, realign_boundaries=True):         \"\"\"         return [text[s:e] for s, e in self.span_tokenize(text, realign_boundaries)]      def _slices_from_text(self, text):         last_break = 0         for match in self._lang_vars.period_context_re().finditer(text):             context = match.group() + match.group(\"after_tok\")             if self.text_contains_sentbreak(context):                 yield slice(last_break, match.end())                 if match.group(\"next_tok\"):"}
{"suffix": "def delete_pool(name):   @api_experimental.route('/lineage/<string:dag_id>/<string:execution_date>', methods=['GET']) def get_lineage(dag_id: str, execution_date: str):     \"\"\"Get Lineage details for a DagRun\"\"\"     # Convert string datetime into actual datetime"}
{"suffix": "def copy_with(self, **kwargs: typing.Any) -> \"URL\":         #  \\_/   \\______________/\\_________/ \\_________/ \\__/         #   |           |            |            |        |         # scheme     authority       path        query   fragment         return URL(self._uri_reference.copy_with(**kwargs).unsplit())      def copy_set_param(self, key: str, value: typing.Any = None) -> \"URL\":         return self.copy_with(params=self.params.set(key, value))"}
{"suffix": "def makecmdoptions(self):     def __str__(self):         return \"<SvnAuth username=%s ...>\" %(self.username,)  rex_blame = re.compile(r'\\s*(\\d+)\\s*(\\S+) (.*)')  class SvnWCCommandPath(common.PathBase):     \"\"\" path implementation offering access/modification to svn working copies."}
{"suffix": "'transparent': (0, 0, 0, 0), }  RGBA = re.compile(r'rgba\\([ \\n\\r\\t]*(.+?)[ \\n\\r\\t]*\\)') RGB = re.compile(r'rgb\\([ \\n\\r\\t]*(.+?)[ \\n\\r\\t]*\\)') HEX_RRGGBB = re.compile('#[0-9a-f]{6}') HEX_RGB = re.compile('#[0-9a-f]{3}')  def color(string, opacity=1):     if match:         r, g, b, a = tuple(             float(i.strip(' %')) / 100 if '%' in i else float(i) / 255             for i in match.group(1).split(','))         return (r, g, b, a * 255 * opacity)      match = RGB.search(string)     if match:         r, g, b = tuple(             float(i.strip(' %')) / 100 if '%' in i else float(i) / 255             for i in match.group(1).split(','))         return (r, g, b, opacity)      match = HEX_RRGGBB.search(string)"}
{"suffix": "import typing  import flask  app = flask.Flask(\"xmpp-http-upload\") app.config.from_envvar(\"XMPP_HTTP_UPLOAD_CONFIG\")     CORS(app)   def sanitized_join(path: str, root: pathlib.Path) -> pathlib.Path:     result = (root / path).absolute()     if not str(result).startswith(str(root) + \"/\"):         raise ValueError(\"resulting path is outside root\")     return result   def get_paths(base_path: pathlib.Path):     data_file = pathlib.Path(str(base_path) + \".data\")     metadata_file = pathlib.Path(str(base_path) + \".meta\")      return data_file, metadata_file  def load_metadata(metadata_file):         return json.load(f)   def get_info(path: str, root: pathlib.Path) -> typing.Tuple[         pathlib.Path,         dict]:     dest_path = sanitized_join(         path,         pathlib.Path(app.config[\"DATA_ROOT\"]),     )      data_file, metadata_file = get_paths(dest_path)      return data_file, load_metadata(metadata_file)  def stream_file(src, dest, nbytes): @app.route(\"/<path:path>\", methods=[\"PUT\"]) def put_file(path):     try:         dest_path = sanitized_join(             path,             pathlib.Path(app.config[\"DATA_ROOT\"]),         )     except ValueError:         return flask.Response(             \"Not Found\",             404, def put_file(path):         \"application/octet-stream\",     )      dest_path.parent.mkdir(parents=True, exist_ok=True, mode=0o770)     data_file, metadata_file = get_paths(dest_path)      try:         with write_file(data_file) as fout: def generate_headers(response_headers, metadata_headers): @app.route(\"/<path:path>\", methods=[\"HEAD\"]) def head_file(path):     try:         data_file, metadata = get_info(             path,             pathlib.Path(app.config[\"DATA_ROOT\"])         )          stat = data_file.stat()     except (OSError, ValueError):         return flask.Response(             \"Not Found\",             404, def head_file(path): @app.route(\"/<path:path>\", methods=[\"GET\"]) def get_file(path):     try:         data_file, metadata = get_info(             path,             pathlib.Path(app.config[\"DATA_ROOT\"])         )     except (OSError, ValueError):         return flask.Response(             \"Not Found\",             404,"}
{"suffix": "def __str__(self):   class Application:     SOCKTYPES = {         \"tcp\": socket.SOCK_STREAM,         \"udp\": socket.SOCK_DGRAM, def __call__(self, env, start_response):             try:                 length = int(env[\"CONTENT_LENGTH\"])             except AttributeError:                 length = -1             try:                 pr = codec.decode(env[\"wsgi.input\"].read(length))             except codec.ParsingError as e:"}
{"suffix": "def branch_exists(self, branch):         \"\"\"         try:             heads = subprocess.run(                 [\"git\", \"ls-remote\", \"--heads\", self.git_url],                 capture_output=True,                 text=True,                 check=True             )             tags = subprocess.run(                 [\"git\", \"ls-remote\", \"--tags\", self.git_url],                 capture_output=True,                 text=True,                 check=True def resolve_default_branch(self):         \"\"\"         try:             head_branch = subprocess.run(                 [\"git\", \"ls-remote\", \"--symref\", self.git_url, \"HEAD\"],                 capture_output=True,                 text=True,                 check=True def initialize_repo(self):         if self.depth and self.depth > 0:             clone_args.extend(['--depth', str(self.depth)])         clone_args.extend(['--branch', self.branch_name])         clone_args.extend([self.git_url, self.repo_dir])         yield from execute_cmd(clone_args)         logging.info('Repo {} initialized'.format(self.repo_dir))"}
{"suffix": "def _unzip_iter(filename, root, verbose=True):         yield ErrorMessage(filename, e)         return      # Get lists of directories & files     namelist = zf.namelist()     dirlist = set()     for x in namelist:         if x.endswith('/'):             dirlist.add(x)         else:             dirlist.add(x.rsplit('/', 1)[0] + '/')     filelist = [x for x in namelist if not x.endswith('/')]      # Create the target directory if it doesn't exist     if not os.path.exists(root):         os.mkdir(root)      # Create the directory structure     for dirname in sorted(dirlist):         pieces = dirname[:-1].split('/')         for i in range(len(pieces)):             dirpath = os.path.join(root, *pieces[: i + 1])             if not os.path.exists(dirpath):                 os.mkdir(dirpath)      # Extract files.     for i, filename in enumerate(filelist):         filepath = os.path.join(root, *filename.split('/'))          try:             with open(filepath, 'wb') as dstfile, zf.open(filename) as srcfile:                 shutil.copyfileobj(srcfile, dstfile)         except Exception as e:             yield ErrorMessage(filename, e)             return          if verbose and (i * 10 / len(filelist) > (i - 1) * 10 / len(filelist)):             sys.stdout.write('.')             sys.stdout.flush()     if verbose:         print()"}
{"suffix": "import mimetypes import os import os.path import re import socketserver import threading def condition():         if path == \"/js/livereload.js\":             file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"livereload.js\")         elif path.startswith(self.mount_path):             rel_file_path = path[len(self.mount_path):].lstrip(\"/\")             if path.endswith(\"/\"):                 rel_file_path += \"index.html\"             file_path = os.path.join(self.root, rel_file_path)         elif path == \"/\":             start_response(\"302 Found\", [(\"Location\", self.mount_path)])"}
{"suffix": "def parse_native_url(url):         result = re.match(             r'^https?://maker\\.ifttt\\.com/use/'             r'(?P<webhook_id>[A-Z0-9_-]+)'             r'/?(?P<events>([A-Z0-9_-]+/?)+)?'             r'/?(?P<params>\\?.+)?$', url, re.I)          if result:"}
{"suffix": "def interpret(): @app.route(\"/file/<path:path>\", methods=[\"GET\"]) @login_check def file(path):     path = secure_filename(path)     if app.interface.encrypt and isinstance(app.interface.examples, str) and path.startswith(app.interface.examples):         with open(os.path.join(app.cwd, path), \"rb\") as encrypted_file:             encrypted_data = encrypted_file.read()         file_data = encryptor.decrypt(             app.interface.encryption_key, encrypted_data)         return send_file(io.BytesIO(file_data), attachment_filename=os.path.basename(path))     else:         return send_file(os.path.join(app.cwd, path))   @app.route(\"/api/queue/push/\", methods=[\"POST\"])"}
{"suffix": "def process_attachments(followup, attached_files):                 'application/octet-stream',                 size=attached.size,             )             att.save()              if attached.size < max_email_attachment_size:"}
{"suffix": "import os import re from collections import defaultdict  from flask import (     Response, def _add_additional_assets(hook): def login():     from flask_login import current_user      redirect_url = request.args.get(\"redirect\", request.script_root + url_for(\"index\"))     permissions = sorted(         filter(             lambda x: x is not None and isinstance(x, OctoPrintPermission),"}
{"suffix": "import os import Bcfg2.Server.Plugin   def async_run(prog, args):     pid = os.fork()     if pid:         os.waitpid(pid, 0)     else:         dpid = os.fork()         if not dpid:             os.system(\" \".join([prog] + args))         os._exit(0)   class Trigger(Bcfg2.Server.Plugin.Plugin,               Bcfg2.Server.Plugin.Statistics): def __init__(self, core, datastore):                               \"unloading\" % self.data)             raise Bcfg2.Server.Plugin.PluginInitError      def process_statistics(self, metadata, _):         args = [metadata.hostname, '-p', metadata.profile, '-g',                 ':'.join([g for g in metadata.groups])]         for notifier in os.listdir(self.data):             if ((notifier[-1] == '~') or                 (notifier[:2] == '.#') or                 (notifier[-4:] == '.swp') or                 (notifier in ['SCCS', '.svn', '4913'])):                 continue             npath = self.data + '/' + notifier             self.logger.debug(\"Running %s %s\" % (npath, \" \".join(args)))             async_run(npath, args)"}
{"suffix": "class AffinityFilter(filters.BaseHostFilter):     def __init__(self):         self.compute_api = compute.API()      def _affinity_host(self, context, instance_id):         return self.compute_api.get(context, instance_id)['host']   class DifferentHostFilter(AffinityFilter): def host_passes(self, host_state, filter_properties):         if isinstance(affinity_uuids, basestring):             affinity_uuids = [affinity_uuids]         if affinity_uuids:             return not any([i for i in affinity_uuids                               if self._affinity_host(context, i) == me])         # With no different_host key         return True  def host_passes(self, host_state, filter_properties):         if isinstance(affinity_uuids, basestring):             affinity_uuids = [affinity_uuids]         if affinity_uuids:             return any([i for i                           in affinity_uuids                           if self._affinity_host(context, i) == me])         # With no same_host key         return True"}
{"suffix": "from django.conf import settings from django.contrib import messages from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ from keystoneclient import exceptions as keystone_exceptions  def handle(self, request, data):         request.session['region_endpoint'] = endpoint         request.session['region_name'] = region_name          redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")          if data.get('tenant', None):             try:"}
{"suffix": "def configure():     register_cli_str('pydev-debug-host', default=None)     register_cli_int('pydev-debug-port', default=None)      register_str('admin_token', default='ADMIN')     register_str('bind_host', default='0.0.0.0')     register_int('compute_port', default=8774)     register_int('admin_port', default=35357) def configure():     # ldap     register_str('url', group='ldap', default='ldap://localhost')     register_str('user', group='ldap', default=None)     register_str('password', group='ldap', default=None)     register_str('suffix', group='ldap', default='cn=example,cn=com')     register_bool('use_dumb_member', group='ldap', default=False)     register_str('dumb_member', group='ldap', default='cn=dumb,dc=nonexistent')"}
{"suffix": "def nav_path(request):     path_parts.append(part)     is_last = len(path_parts) == len(request.path_parts)      item = _item(name=part, href=None)      if not is_last or (is_dir and request.view_func is not view_directory):       item.href = request.get_url(view_func=view_directory,"}
{"suffix": "def _checkPolkitPrivilege(self, sender, conn, privilege):             # bus, and it does not make sense to restrict operations here             return          info = SenderInfo(sender, conn)          # get peer PID         pid = info.connectionPid()          # query PolicyKit         self._initPolkit()         try:             # we don't need is_challenge return here, since we call with AllowUserInteraction             (is_auth, _, details) = self.polkit.CheckAuthorization(                     ('unix-process', {'pid': dbus.UInt32(pid, variant_level=1),                     'start-time': dbus.UInt64(0, variant_level=1)}),                     privilege, {'': ''}, dbus.UInt32(1), '', timeout=3000)         except dbus.DBusException as e:             if e._dbus_error_name == 'org.freedesktop.DBus.Error.ServiceUnknown':"}
{"suffix": "def encode(self):  def constructObject(data):     try:         classBase = eval(data[\"\"] + \".\" + data[\"\"].title())     except NameError:         logger.error(\"Don't know how to handle message type: \\\"%s\\\"\", data[\"\"])         return None     try:         returnObj = classBase()"}
{"suffix": "def sendEmail(sydent, templateName, mailTo, substitutions):             allSubstitutions[k+\"_forhtml\"] = cgi.escape(v.decode('utf8'))             allSubstitutions[k+\"_forurl\"] = urllib.quote(v)          mailString = open(mailTemplateFile).read() % allSubstitutions         rawFrom = email.utils.parseaddr(mailFrom)[1]         rawTo = email.utils.parseaddr(mailTo)[1]         if rawFrom == '' or rawTo == '':             logger.info(\"Couldn't parse from / to address %s / %s\", mailFrom, mailTo)             raise EmailAddressException()         mailServer = sydent.cfg.get('email', 'email.smtphost')         mailPort = sydent.cfg.get('email', 'email.smtpport')         mailUsername = sydent.cfg.get('email', 'email.smtpusername') def sendEmail(sydent, templateName, mailTo, substitutions):                 smtp = smtplib.SMTP(mailServer, mailPort, myHostname)             if mailUsername != '':                 smtp.login(mailUsername, mailPassword)             smtp.sendmail(rawFrom, rawTo, mailString.encode('utf-8'))             smtp.quit()         except Exception as origException:             twisted.python.log.err()"}
{"suffix": "def get_link_re() -> str:      # [text](url) or [text](<url>) or [text](url \"title\")     LINK_RE = NOIMG + BRK + \\         r'''\\(\\s*(<.*?>|((?:(?:\\(.*?\\))|[^\\(\\)]))*?)\\s*((['\"])(.*?)\\12\\s*)?\\)'''     return normal_compile(LINK_RE)  def prepare_realm_pattern(source: str) -> str:"}
{"suffix": "import subprocess import syslog from jadi import component, service, interface  import aj from aj.api.http import BaseHttpHandler class OSAuthenticationProvider(AuthenticationProvider):      def authenticate(self, username, password):         child = None         try:             child = pexpect.spawn('/bin/sh', ['-c', '/bin/su -c \"/bin/echo SUCCESS\" - %s' % username], timeout=5)             child.expect('.*:')             child.sendline(password)             result = child.expect(['su: .*', 'SUCCESS'])"}
{"suffix": "from app import apfell, links, use_ssl from sanic import response from jinja2 import Environment, PackageLoader from sanic_jwt.decorators import scoped, inject_user from app.routes.routes import respect_pivot import urllib.parse  env = Environment(loader=PackageLoader('app', 'templates'))  async def apiui_command_help(request, user):     template = env.get_template('apiui_command_help.html')     if len(request.query_args) != 0:         data = urllib.parse.unquote(request.query_args[0][1])         print(data)     else:         data = \"\"     if use_ssl:"}
{"suffix": "def pref_get(key):         return \"Authentication required\", 401      if key in get_preferences():         return Response(json.dumps({'key': key, 'value': get_preferences()[key]}))     else:         return Response(json.dumps({'key': key, 'error': 'novalue'}))   @app.route(\"/api/preferences/set/<key>/<value>\") def pref_set(key, value):         return \"Authentication required\", 401      get_preferences()[key] = (None if value == 'null' else value)     return Response(json.dumps({'key': key, 'success': ''})), 201   if __name__ == '__main__':"}
{"suffix": "def view_directory(request):       if request.roottype == 'cvs' and file.rev is not None:         row.rev = None         if cfg.options.show_logs:           row.log_file = file.newest_file           row.log_rev = file.rev        if request.roottype == 'svn':"}
{"suffix": "def rreplace(s, old, new, occurrence):      p = Process(config_section)      PASTES_FOLDER = os.path.join(os.environ['AIL_HOME'], p.config.get(\"Directories\", \"pastes\"))     PASTES_FOLDERS = PASTES_FOLDER + '/'      # LOGGING #     publisher.info(\"Feed Script started to receive & publish.\") def rreplace(s, old, new, occurrence):             time.sleep(1)             continue          file_name_paste = paste.split('/')[-1]         if len(file_name_paste)>255:             new_file_name_paste = '{}{}.gz'.format(file_name_paste[:215], str(uuid.uuid4()))             paste = rreplace(paste, file_name_paste, new_file_name_paste, 1)          # Creating the full filepath         filename = os.path.join(PASTES_FOLDER, paste)          dirname = os.path.dirname(filename)         if not os.path.exists(dirname):             os.makedirs(dirname)          decoded = base64.standard_b64decode(gzip64encoded)          with open(filename, 'wb') as f:             f.write(decoded)         '''try:             decoded2 = gunzip_bytes_obj(decoded)         except:             decoded2 =''          type = magic.from_buffer(decoded2, mime=True)          if type!= 'text/x-c++' and type!= 'text/html' and type!= 'text/x-c' and type!= 'text/x-python' and type!= 'text/x-php' and type!= 'application/xml' and type!= 'text/x-shellscript' and type!= 'text/plain' and type!= 'text/x-diff' and type!= 'text/x-ruby':              print('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------')             print(filename)             print(type)             print('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------')         '''          # remove PASTES_FOLDER from item path (crawled item + submited)         if PASTES_FOLDERS in paste:             paste = paste.replace(PASTES_FOLDERS, '', 1)          p.populate_set_out(paste)         processed_paste+=1"}
{"suffix": "def post(self, request, *args, **kwargs):                     code.delete()                     return self.issue_token(user)          return self.issue_token(user)   class RegenerateBackupCodesView(APIView):"}
{"suffix": "async def ip(ctx , *, argument):  @Client.command() async def dirsearch(ctx , *, argument):     Path = TOOLS['dirsearch']; MainPath = getcwd(); chdir(Path)     await ctx.send(f\"**Running Your Dirsearch Scan, We Will Send The Results When It's Done**\")     Process = subprocess.Popen(f'python3 dirsearch.py -u {argument} -e * -b' , shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT) async def dirsearch(ctx , *, argument):  @Client.command() async def arjun(ctx , *, argument):     Path = TOOLS['arjun']; MainPath = getcwd(); chdir(Path)     await ctx.send(f\"**Running Your Arjun Scan, We Will Send The Results When It's Done**\")     await ctx.send(f\"**Note: The Bot Won't Respond Until The Scan is Done. All Of Your Commands Now Will Be Executed After This Process is Done.\")"}
{"suffix": "def load():     database_name = f\"{autocomplete_filepath}{os.path.sep}{RTXConfig.autocomplete_path.split('/')[-1]}\"     conn = sqlite3.connect(database_name)     cursor = conn.cursor()     return True   def get_nodes_like(word,requested_limit):     if len(word) < 2:         return values      floor = word[:-1]     ceiling = floor + 'zz'  def get_nodes_like(word,requested_limit):         if found_fragment is None:              #### Cache this fragment in the database             cursor.execute(\"INSERT INTO cached_fragments(fragment) VALUES(?)\", (word,))             fragment_id = cursor.lastrowid             if debug:                 print(f\"fragment_id = {fragment_id}\")"}
{"suffix": "import sys import rtxcomplete import traceback  #class MainHandler(tornado.web.RequestHandler): #    def get(self): #        self.write(\"Hello, world\") #print __file__  root = os.path.dirname(os.path.abspath(__file__)) rtxcomplete.load() #conn = sqlite3.connect('dict.db') #conn.enable_load_extension(True) #conn.load_extension(\"./spellfix\") #cursor = conn.cursor()  class autoSearch(tornado.web.RequestHandler):      def get(self, arg,word=None):         #print \"match auto\"         try:             limit = self.get_argument(\"limit\")             word = self.get_argument(\"word\")             callback = self.get_argument(\"callback\") #jsonp              result = rtxcomplete.prefix(word,limit)              result = callback+\"(\"+json.dumps(result)+\");\" #jsonp             #result = json.dumps(result) #typeahead                          self.write(result)              def get(self, arg,word=None):         try:             limit = self.get_argument(\"limit\")             word = self.get_argument(\"word\")             callback = self.get_argument(\"callback\")             #print word             #cursor.execute(\"SELECT word FROM spell WHERE word MATCH \\\"\" + word + \"\\\" LIMIT \" + limit)             #cursor.execute(\"SELECT word FROM spell WHERE word MATCH \\\"\" + word + \"*\\\" LIMIT \" + limit) def get(self, arg,word=None):         try:             limit = self.get_argument(\"limit\")             word = self.get_argument(\"word\")             callback = self.get_argument(\"callback\")             #print word             #cursor.execute(\"SELECT word FROM spell WHERE word MATCH \\\"\" + word + \"\\\" LIMIT \" + limit)             #cursor.execute(\"SELECT word FROM spell WHERE word MATCH \\\"\" + word + \"*\\\" LIMIT \" + limit) def get(self, arg,word=None):  class nodesLikeSearch(tornado.web.RequestHandler):     def get(self, arg,word=None):         #try:         if 1 == 1:             limit = self.get_argument(\"limit\")             word = self.get_argument(\"word\")             callback = self.get_argument(\"callback\")             result = rtxcomplete.get_nodes_like(word,limit);             result = callback+\"(\"+json.dumps(result)+\");\"             self.write(result)         #except:         #    print(sys.exc_info()[:])         #    traceback.print_tb(sys.exc_info()[-1])         #    self.write(\"error\")   class defineSearch(tornado.web.RequestHandler):"}
{"suffix": "import tldextract import logging import shutil  from threading import Thread  def get_whois(ip_domain, save_db=False, fetch_from_db=True): def get_cms_details(url):     # this function will fetch cms details using cms_detector     response = {}     cms_detector_command = 'python3 /usr/src/github/CMSeeK/cmseek.py -u {} --random-agent --batch --follow-redirect'.format(url)     os.system(cms_detector_command)      response['status'] = False     response['message'] = 'Could not detect CMS!'"}
{"suffix": "import random from html import escape from os import remove  import magic from flask import Flask, abort, request from PIL import Image def uploadimage():     ):  # if it is not over the limit, it will skip. if it is, it does this.         # if we have gone over our cache limit, let's delete the first entry.         filename = all_files[0][1] + all_files[0][2]         remove(filename)         del all_files[0]         length = len(all_files)"}
{"suffix": "def get(image_file, domain, title, singer, album):     import json     import os     from html import unescape      import requests      api = f\"http://{domain}:7873/bGVhdmVfcmlnaHRfbm93\"      with open(image_file, \"rb\") as f:"}
{"suffix": "print(e)  if form.getvalue('getcert') is not None and serv is not None:     cert_id = form.getvalue('getcert')     if funct.checkAjaxInput(cert_id):         print('error: Nice try')         sys.exit()      cert_path = sql.get_setting('cert_path')     commands = [\"openssl x509 -in \" + cert_path + \"/\" + cert_id + \" -text\"]         print('error: Cannot connect to the server ' + e.args[0])  if form.getvalue('delcert') is not None and serv is not None:     if funct.checkAjaxInput(cert_id):         print('error: Nice try')         sys.exit()      cert_path = sql.get_setting('cert_path')     commands = [\"sudo rm -f \" + cert_path + \"/\" + cert_id]     try:     if form.getvalue('ssl_name') is None:         print('error: Please enter a desired name')     else:         name = form.getvalue('ssl_name')         if funct.checkAjaxInput(name):             print('error: Nice try')             sys.exit()      try:         with open(name, \"w\") as ssl_cert:  if form.getvalue('ipbackend') is not None and form.getvalue('backend_server') is None:     haproxy_sock_port = int(sql.get_setting('haproxy_sock_port'))     backend = form.getvalue('ipbackend')     if funct.checkAjaxInput(backend):         print('error: Nice try')         sys.exit()     cmd = 'echo \"show servers state\"|nc %s %s |grep \"%s\" |awk \\'{print $4}\\'' % (serv, haproxy_sock_port, backend)     output, stderr = funct.subprocess_execute(cmd)     for i in output:  if form.getvalue('ipbackend') is not None and form.getvalue('backend_server') is not None:     haproxy_sock_port = int(sql.get_setting('haproxy_sock_port'))     backend = form.getvalue('ipbackend')     backend_server = form.getvalue('backend_server')     if funct.checkAjaxInput(backend) or funct.checkAjaxInput(backend_server):         print('error: Nice try')         sys.exit()     cmd = 'echo \"show servers state\"|nc %s %s |grep \"%s\" |grep \"%s\" |awk \\'{print $5\":\"$19}\\' |head -1' % (serv, haproxy_sock_port, backend, backend_server)     output, stderr = funct.subprocess_execute(cmd)     print(output[0])  if form.getvalue('backend_ip') is not None:     backend_backend = form.getvalue('backend_backend')     backend_server = form.getvalue('backend_server')     backend_ip = form.getvalue('backend_ip')     backend_port = form.getvalue('backend_port')     if any((funct.checkAjaxInput(backend_backend), funct.checkAjaxInput(backend_server), funct.checkAjaxInput(backend_ip), funct.checkAjaxInput(backend_port))):         print('error: Nice try')         sys.exit()     if form.getvalue('backend_ip') is None:         print('error: Backend IP must be IP and not 0')         sys.exit()         stderr = funct.master_slave_upload_and_restart(serv, cfg, just_save='save')  if form.getvalue('maxconn_select') is not None:     serv = form.getvalue('maxconn_select')     if funct.checkAjaxInput(serv):         print('error: Nice try')         sys.exit()     funct.get_backends_from_config(serv, backends='frontend')  if form.getvalue('maxconn_frontend') is not None:     frontend = form.getvalue('maxconn_frontend')     maxconn = form.getvalue('maxconn_int')      if funct.checkAjaxInput(frontend) or funct.checkAjaxInput(maxconn):         print('error: Nice try')         sys.exit()     if form.getvalue('maxconn_int') is None:         print('error: Maxconn must be integer and not 0')         sys.exit()  if form.getvalue('ip_for_delete') is not None:     haproxy_sock_port = sql.get_setting('haproxy_sock_port')     ip = form.getvalue('ip_for_delete')     table = form.getvalue('table_for_delete')      if funct.checkAjaxInput(ip) or funct.checkAjaxInput(table):         print('error: Nice try')         sys.exit()      cmd = 'echo \"clear table %s key %s\" |nc %s %s' % (table, ip, serv, haproxy_sock_port)     output, stderr = funct.subprocess_execute(cmd)  if form.getvalue('table_for_clear') is not None:     haproxy_sock_port = sql.get_setting('haproxy_sock_port')     table = form.getvalue('table_for_clear')      if funct.checkAjaxInput(table):         print('error: Nice try')         sys.exit()      cmd = 'echo \"clear table %s \" |nc %s %s' % (table, serv, haproxy_sock_port)     output, stderr = funct.subprocess_execute(cmd)     env = Environment(loader=FileSystemLoader('templates/'), autoescape=True,                       extensions=['jinja2.ext.loopcontrols', 'jinja2.ext.do'], trim_blocks=True, lstrip_blocks=True)     template = env.get_template('ajax/list.html')     list_id = form.getvalue('list_select_id')     list_name = form.getvalue('list_select_name')      if funct.checkAjaxInput(list_id) or funct.checkAjaxInput(list_name):         print('error: Nice try')         sys.exit()      haproxy_sock_port = sql.get_setting('haproxy_sock_port')     cmd = 'echo \"show acl #%s\"|nc %s %s' % (list_id, serv, haproxy_sock_port) if form.getvalue('list_id_for_delete') is not None:     haproxy_sock_port = sql.get_setting('haproxy_sock_port')     lists_path = sql.get_setting('lists_path')     lib_path = funct.get_config_var('main', 'lib_path')     ip_id = form.getvalue('list_ip_id_for_delete')     ip = form.getvalue('list_ip_for_delete')     list_id = form.getvalue('list_id_for_delete')     list_name = form.getvalue('list_name')     user_group = funct.get_user_group(id=1)      if any((funct.checkAjaxInput(ip_id), funct.checkAjaxInput(ip), funct.checkAjaxInput(list_id), funct.checkAjaxInput(list_name))):         print('error: Nice try')         sys.exit()      cmd = \"sed -i 's!%s$!!' %s/%s/%s/%s\" % (ip, lib_path, lists_path, user_group, list_name)     cmd1 = \"sed -i '/^$/d' %s/%s/%s/%s\" % (lib_path, lists_path, user_group, list_name)     output, stderr = funct.subprocess_execute(cmd)     ip = form.getvalue('list_ip_for_add')     ip = ip.strip()     ip = funct.is_ip_or_dns(ip)     list_id = form.getvalue('list_id_for_add')     list_name = form.getvalue('list_name')     user_group = funct.get_user_group(id=1)      if any((funct.checkAjaxInput(lists_path), funct.checkAjaxInput(list_id), funct.checkAjaxInput(list_name))):         print('error: Nice try')         sys.exit()      cmd = 'echo \"add acl #%s %s\" |nc %s %s' % (list_id, ip, serv, haproxy_sock_port)     output, stderr = funct.subprocess_execute(cmd)     if output[0]:      env = Environment(loader=FileSystemLoader('templates'), autoescape=True,                       extensions=['jinja2.ext.loopcontrols', 'jinja2.ext.do'], trim_blocks=True, lstrip_blocks=True)     serv = form.getvalue('sessions_select')      if funct.checkAjaxInput(serv):         print('error: Nice try')         sys.exit()      if funct.checkAjaxInput(serv):         print('error: Nice try')         sys.exit()      haproxy_sock_port = sql.get_setting('haproxy_sock_port')      print(template)  if form.getvalue('sessions_select_show') is not None:     serv = form.getvalue('sessions_select_show')     sess_id = form.getvalue('sessions_select_id')      if funct.checkAjaxInput(serv) or funct.checkAjaxInput(sess_id):         print('error: Nice try')         sys.exit()      haproxy_sock_port = sql.get_setting('haproxy_sock_port')      cmd = 'echo \"show sess %s\" |nc %s %s' % (sess_id, serv, haproxy_sock_port)     output, stderr = funct.subprocess_execute(cmd)      if stderr:  if form.getvalue('session_delete_id') is not None:     haproxy_sock_port = sql.get_setting('haproxy_sock_port')     sess_id = form.getvalue('session_delete_id')      if funct.checkAjaxInput(sess_id):         print('error: Nice try')         sys.exit()      if funct.checkAjaxInput(sess_id):         print('error: Nice try')         sys.exit()      cmd = 'echo \"shutdown session %s\" |nc %s %s' % (sess_id, serv, haproxy_sock_port)     output, stderr = funct.subprocess_execute(cmd)     if output[0] != '':     print(\"success: Apache has been %s\" % action)  if form.getvalue('action_service') is not None:     action = form.getvalue('action_service')      if funct.checkAjaxInput(action):         print('error: Nice try')         sys.exit()      if funct.checkAjaxInput(action):         print('error: Nice try')         sys.exit()      if action not in ('start', 'stop', 'restart'):         print('error: wrong action') async def get_runner_overviewServers(**kwargs): if form.getvalue('servaction') is not None:     server_state_file = sql.get_setting('server_state_file')     haproxy_sock = sql.get_setting('haproxy_sock')     enable = form.getvalue('servaction')     backend = form.getvalue('servbackend')      if funct.checkAjaxInput(enable) or funct.checkAjaxInput(backend):         print('error: Nice try')         sys.exit()      cmd = 'echo \"{} {}\" |sudo socat stdio {}'.format(enable, backend, haproxy_sock)  async def get_runner_overviewServers(**kwargs): if serv is not None and form.getvalue('right') is not None:     from jinja2 import Environment, FileSystemLoader      left = form.getvalue('left')     right = form.getvalue('right')      if funct.checkAjaxInput(left) or funct.checkAjaxInput(right):         print('error: Nice try')         sys.exit()      if form.getvalue('service') == 'nginx':         configs_dir = funct.get_config_var('configs', 'nginx_save_configs_dir') async def get_runner_overviewServers(**kwargs):  if form.getvalue('sshdel') is not None:     lib_path = funct.get_config_var('main', 'lib_path')     sshdel = form.getvalue('sshdel')      if funct.checkAjaxInput(sshdel):         print('error: Nice try')         sys.exit()      if funct.checkAjaxInput(sshdel):         print('error: Nice try')         sys.exit()      for sshs in sql.select_ssh(id=sshdel):         ssh_enable = sshs.enable async def get_runner_overviewServers(**kwargs):     import paramiko      user_group = funct.get_user_group()     name = form.getvalue('name')      if funct.checkAjaxInput(name):         print('error: Nice try')         sys.exit()      try:         key = paramiko.pkey.load_private_key(form.getvalue('ssh_cert')) async def get_runner_overviewServers(**kwargs):         funct.logging('SMON', ' Has been update the server ' + ip + ' to SMON ', haproxywi=1, login=1)  if form.getvalue('showBytes') is not None:     serv = form.getvalue('showBytes')      if funct.checkAjaxInput(serv):         print('error: Nice try')         sys.exit()      port = sql.get_setting('haproxy_sock_port')     bin_bout = [] async def get_runner_overviewServers(**kwargs):         print('error: cannot connect to Nginx stat page')  if form.getvalue('waf_rule_id'):     enable = form.getvalue('waf_en')     rule_id = form.getvalue('waf_rule_id')      if funct.checkAjaxInput(enable) or funct.checkAjaxInput(rule_id):         print('error: Nice try')         sys.exit()      haproxy_path = sql.get_setting('haproxy_dir')     rule_file = sql.select_waf_rule_by_id(rule_id) async def get_runner_overviewServers(**kwargs):     os.system(\"rm -f %s\" % script)  if form.getvalue('uploadovpn'):     name = form.getvalue('ovpnname')      if funct.checkAjaxInput(name):         print('error: Nice try')         sys.exit()      if funct.checkAjaxInput(name):         print('error: Nice try')         sys.exit()      ovpn_file = os.path.dirname('/tmp/') + \"/\" + name + '.ovpn'  async def get_runner_overviewServers(**kwargs):     funct.logging(\"localhost\", \" has been uploaded a new ovpn file %s\" % ovpn_file, haproxywi=1, login=1)  if form.getvalue('openvpndel') is not None:     openvpndel = form.getvalue('openvpndel')      if funct.checkAjaxInput(openvpndel):         print('error: Nice try')         sys.exit()      cmd = 'sudo openvpn3 config-remove --config /tmp/%s.ovpn --force' % openvpndel     try: async def get_runner_overviewServers(**kwargs):         funct.logging('localhost', e.args[0], haproxywi=1)  if form.getvalue('actionvpn') is not None:     openvpn = form.getvalue('openvpnprofile')     action = form.getvalue('actionvpn')      if funct.checkAjaxInput(openvpn) or funct.checkAjaxInput(action):         print('error: Nice try')         sys.exit()      if action == 'start':         cmd = 'sudo openvpn3 session-start --config /tmp/%s.ovpn' % openvpn async def get_runner_overviewServers(**kwargs):         funct.logging('localhost', e.args[0], haproxywi=1)  if form.getvalue('scan_ports') is not None:     serv_id = form.getvalue('scan_ports')      if funct.checkAjaxInput(serv_id):         print('error: Nice try')         sys.exit()      server = sql.select_servers(id=serv_id)     ip = ''  async def get_runner_overviewServers(**kwargs):         print(template)  if form.getvalue('viewFirewallRules') is not None:     serv = form.getvalue('viewFirewallRules')      if funct.checkAjaxInput(serv):         print('error: Nice try')         sys.exit()      cmd = [\"sudo iptables -L INPUT -n --line-numbers|sed 's/  */ /g'|grep -v -E 'Chain|target'\"]     cmd1 = [\"sudo iptables -L IN_public_allow -n --line-numbers|sed 's/  */ /g'|grep -v -E 'Chain|target'\"] async def get_runner_overviewServers(**kwargs):  if form.getvalue('geoipserv') is not None:     serv = form.getvalue('geoipserv')      if funct.checkAjaxInput(serv):         print('error: Nice try')         sys.exit()      haproxy_dir = sql.get_setting('haproxy_dir')      cmd = [\"ls \" + haproxy_dir + \"/geoip/\"] async def get_runner_overviewServers(**kwargs):     user_uuid = cookie.get('uuid')     user_id = sql.get_user_id_by_uuid(user_uuid.value)     user_services = sql.select_user_services(user_id)     server_id = form.getvalue('server_id')     service = form.getvalue('service')      if funct.checkAjaxInput(server_id) or funct.checkAjaxInput(service):         print('error: Nice try')         sys.exit()      if '1' in user_services:         if service == 'haproxy':"}
{"suffix": "from flaskbb.extensions import allows, db, celery from flaskbb.user.models import User, Group from flaskbb.forum.models import Post  from hub.forms import ConfigEditForm, BanSearchForm, ConnectionSearchForm from hub.permissions import CanAccessServerHub, CanAccessServerHubAdditional, CanAccessServerHubManagement def get(self):         if server is None:             abort(404)          file_path = os.path.join(server.logs_path, path)         return send_file(file_path, as_attachment=True)"}
{"suffix": "#!/bin/env python from flask import Flask from flask import flash,request,send_file,send_from_directory,redirect,render_template, abort  from werkzeug.utils import secure_filename from ipaddress import ip_address, ip_network def dir_listing(req_path): https://stackoverflow.com/questions/23718236/python-flask-browsing-through-directory-with-files   '''   # Joining the base and the requested path   abs_path = os.path.join(CONFIG['SRV_DIR'], req_path)    # Return 404 if path doesn't exist   if not os.path.exists(abs_path):"}
{"suffix": "from app.module.user.model import UserModel, UserTokenModel from app.module.user import UserSession from werkzeug.routing import BaseConverter, ValidationError from bson.objectid import ObjectId from bson.errors import InvalidId from os import path @login_required def private_static(filename):     # Get path     filepath = path.join(app.config.get(\"PRIVATE_DIR\"), filename)     if path.isfile(filepath):         return send_file(filepath)     # End"}
{"suffix": "import configparser  from flask import Flask, render_template, session, request, flash, redirect, url_for, Response, abort, jsonify, send_file import socket import os import random def get_absolute_path(path):         import os         script_dir = os.path.dirname(__file__)  # <-- absolute dir the script is in         rel_path = path         abs_file_path = os.path.join(script_dir, rel_path)         return abs_file_path      return send_file("}
{"suffix": "def get_markdown(text):     if not text:         return \"\"      pattern = fr'([\\[\\s\\S\\]]*?)\\(([\\s\\S]*?):([\\[\\s\\S\\]]*?)\\)'     # Regex check     if re.match(pattern, text):         # get get value of group regex"}
{"suffix": "def my_type(value):   email_regex = re.compile(     r\"^\" \"(?P<local>[^@]*[^@.])\" r\"@\" r\"(?P<server>[^@]+(?:\\.[^@]+)*)\" r\"$\",     re.IGNORECASE, )"}
{"suffix": "class NbconvertFileHandler(IPythonHandler):      SUPPORTED_METHODS = ('GET',)      @web.authenticated     def get(self, format, path):  def get(self, format, path): class NbconvertPostHandler(IPythonHandler):     SUPPORTED_METHODS = ('POST',)      @web.authenticated     def post(self, format):         exporter = get_exporter(format, config=self.config)"}
{"suffix": "def key(request, wikiname=None, itemname=None, attachname=None, content=None, se     return key   def put(request, key, data,         filename=None,         content_type=None, def _do_remove(request, key):     remove(request, key)   def _do(request, do, key):     if do == 'get':         _do_get(request, key)     elif do == 'remove':         _do_remove(request, key)  def execute(pagename, request):     do = request.values.get('do')     key = request.values.get('key')     _do(request, do, key)"}
{"suffix": "async def message(self, ctx: commands.Context):      @message.command(name=\"mention\")     @commands.guild_only()     async def with_mention(self, ctx: commands.Context, message: str = None):         \"\"\"Set stream alert message when mentions are enabled.          Use `{mention}` in the message to insert the selected mentions.          Use `{stream.name}` in the message to insert the channel or user name.          For example: `[p]streamset message mention \"{mention}, {stream.name} is live!\"`         \"\"\"         if message is not None:             guild = ctx.guild async def with_mention(self, ctx: commands.Context, message: str = None):      @message.command(name=\"nomention\")     @commands.guild_only()     async def without_mention(self, ctx: commands.Context, message: str = None):         \"\"\"Set stream alert message when mentions are disabled.          Use `{stream.name}` in the message to insert the channel or user name.          For example: `[p]streamset message nomention \"{stream.name} is live!\"`         \"\"\"         if message is not None:             guild = ctx.guild async def check_streams(self):                                 channel.guild                             ).live_message_mention()                             if alert_msg:                                 content = alert_msg.format(mention=mention_str, stream=stream)                             else:                                 content = _(\"{mention}, {stream} is live!\").format(                                     mention=mention_str, async def check_streams(self):                                 channel.guild                             ).live_message_nomention()                             if alert_msg:                                 content = alert_msg.format(stream=stream)                             else:                                 content = _(\"{stream} is live!\").format(                                     stream=escape("}
{"suffix": "import sys import datetime from functools import wraps from werkzeug.utils import secure_filename from werkzeug.security import generate_password_hash, check_password_hash from flask import Flask, request, jsonify, render_template, flash, redirect, url_for, session, send_file, make_response from flask_login import login_user, login_required, logout_user, current_user, UserMixin def job_browse(job_id: int, path):         return redirect(url_for(\"job_page\", job_id=job_id))      # Join the base and the requested path     abs_path = os.path.join(job_base_dir, path)      # URL path variable for going back     back_path = os.path.dirname(abs_path).replace(job_base_dir, \"\")"}
{"suffix": "from apkleaks.colors import clr from contextlib import closing from distutils.spawn import find_executable from pyaxmlparser import APK from urllib.request import urlopen from zipfile import ZipFile def decompile(self): \t\t\t\t\tclasses.write(zipped.read(\"classes.dex\")) \t\t\texcept Exception as e: \t\t\t\tsys.exit(self.writeln(str(e), clr.WARNING)) \t\tdec = \"%s %s -d %s --deobf\" % (self.jadx, dex, self.tempdir) \t\tos.system(dec) \t\treturn self.tempdir  \tdef unique(self, list):"}
{"suffix": "def visit_Call(self, node):         datetime().         \"\"\"         if isinstance(node.func, ast.Name):             expr = None             if node.func.id == 'ObjectId':                 expr = \"('\" + node.args[0].s + \"')\"             elif node.func.id == 'datetime':                 values = []                 for arg in node.args:                     values.append(str(arg.n))                 expr = \"(\" + \", \".join(values) + \")\"             if expr:                 self.current_value = eval(node.func.id + expr)      def visit_Attribute(self, node):         \"\"\" Attribute handler ('Contact.Id')."}
{"suffix": "import ctypes import logging import libarchive  from diffoscope.tempfiles import get_temporary_directory  def close_archive(self):      def get_member_names(self):         self.ensure_unpacked()         return self._member_names      def extract(self, member_name, dest_dir):         self.ensure_unpacked()         return os.path.join(self._unpacked, member_name)      def get_member(self, member_name):         with libarchive.file_reader(self.source.path) as archive: def get_subclass(self, entry):         return LibarchiveMember(self, entry)      def ensure_unpacked(self):         if hasattr(self, '_unpacked'):             return          self._unpacked = get_temporary_directory().name         self._member_names = []          logger.debug(\"Extracting %s to %s\", self.source.path, self._unpacked)          with libarchive.file_reader(self.source.path) as archive:             for entry in archive:                 self._member_names.append(entry.pathname)                  if entry.isdir:                     continue                  # All extracted locations must be underneath self._unpacked                 force_prefix = os.path.join(self._unpacked, \"\")                  # Try to pick a safe and reasonable candidate name                 candidate_name = os.path.normpath(entry.pathname.rstrip('/' + os.sep))                 if os.path.isabs(candidate_name):                     candidate_name = os.path.relpath(candidate_name, os.path.join(os.path.sep))                  dst = os.path.normpath(os.path.join(self._unpacked, candidate_name))                 if not dst.startswith(force_prefix):                     logger.warn(\"Skipping member because we could not make a safe name to extract it to: '%s'\",                                 entry.pathname)                     continue                  # TODO: need to fix reading these cleaned members. currently                 # reading will still try to use the uncleaned name.                 #logging.debug(\"Extracting %s to %s\", entry.pathname, dst)                 os.makedirs(os.path.dirname(dst), exist_ok=True)                  with open(dst, 'wb') as f:                     for block in entry.get_blocks():                         f.write(block)          logger.debug(             \"Extracted %d entries from %s to %s\",             len(self._member_names), self.source.path, self._unpacked,         )"}
{"suffix": "import os  from aim.web.api.utils import APIRouter  # wrapper for fastapi.APIRouter from fastapi.responses import FileResponse  statics_router = APIRouter()   @statics_router.get('/static-files/{path:path}/') async def serve_static_files(path):     from aim import web     static_file_name = os.path.join(os.path.dirname(web.__file__), 'ui', 'build', path)     compressed_file_name = '{}.gz'.format(static_file_name)     if os.path.exists(compressed_file_name):         return FileResponse(compressed_file_name, headers={'Content-Encoding': 'gzip'})"}
{"suffix": "def get_int_arg(value, default=0):             num_dag_to=min(end, num_of_all_dags),             num_of_all_dags=num_of_all_dags,             paging=wwwutils.generate_pages(current_page, num_of_pages,                                            search=arg_search_query,                                            showPaused=not hide_paused),             num_runs=num_runs,             tags=tags)"}
{"suffix": "import re import inspect  __version__ = '0.8' __author__ = 'Hsiaoming Yang <me@lepture.com>' __all__ = [     'BlockGrammar', 'BlockLexer', def _pure_pattern(regex):   def _keyify(key):     return _key_pattern.sub(' ', key.lower())   def escape(text, quote=False, smart_amp=True): class InlineGrammar(object):     inline_html = re.compile(         r'^(?:%s|%s|%s)' % (             r'<!--[\\s\\S]*?-->',             r'<(\\w+%s)((?:%s)*?)\\s*>([\\s\\S]*?)<\\/\\1>' % (_valid_end, _valid_attr),             r'<\\w+%s(?:%s)*?\\s*\\/?>' % (_valid_end, _valid_attr),         )     )"}
{"suffix": "async def get_resolved_ref(self):             self.sha1_validate(self.unresolved_ref)         except ValueError:             # The ref is a head/tag and we resolve it using `git ls-remote`             command = [\"git\", \"ls-remote\", self.repo, self.unresolved_ref]             result = subprocess.run(command, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)             if result.returncode:                 raise RuntimeError(\"Unable to run git ls-remote to get the `resolved_ref`: {}\".format(result.stderr))"}
{"suffix": "def before_upstream_connection(                 raise ProxyAuthenticationFailed()             parts = request.headers[b'proxy-authorization'][1].split()             if len(parts) != 2 \\                     and parts[0].lower() != b'basic' \\                     and parts[1] != self.flags.auth_code:                 raise ProxyAuthenticationFailed()         return request"}
{"suffix": "def _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,     if max_depth > scalar_depth:       raise ValueError(\"Invalid pylist=%r: empty list nesting is greater \"                        \"than scalar value nesting\" % pylist)    # If both inner_shape and ragged_rank were specified, then check that   # they are compatible with pylist."}
{"suffix": "def _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,     if max_depth > scalar_depth:       raise ValueError(\"Invalid pylist=%r: empty list nesting is greater \"                        \"than scalar value nesting\" % pylist)    # If both inner_shape and ragged_rank were specified, then check that   # they are compatible with pylist."}
{"suffix": "def word_tokenize(self, s):         return self._word_tokenizer_re().findall(s)      _period_context_fmt = r\"\"\"         \\S*                          # some word material         %(SentEndChars)s             # a potential sentence ending         (?=(?P<after_tok>             %(NonWord)s              # either other punctuation def debug_decisions(self, text):         See format_debug_decision() to help make this output readable.         \"\"\"          for match in self._lang_vars.period_context_re().finditer(text):             decision_text = match.group() + match.group(\"after_tok\")             tokens = self._tokenize_words(decision_text)             tokens = list(self._annotate_first_pass(tokens))             while tokens and not tokens[0].tok.endswith(self._lang_vars.sent_end_chars): def sentences_from_text(self, text, realign_boundaries=True):         \"\"\"         return [text[s:e] for s, e in self.span_tokenize(text, realign_boundaries)]      def _slices_from_text(self, text):         last_break = 0         for match in self._lang_vars.period_context_re().finditer(text):             context = match.group() + match.group(\"after_tok\")             if self.text_contains_sentbreak(context):                 yield slice(last_break, match.end())                 if match.group(\"next_tok\"):"}
{"suffix": "def delete_pool(name):   @api_experimental.route('/lineage/<string:dag_id>/<string:execution_date>', methods=['GET']) def get_lineage(dag_id: str, execution_date: str):     \"\"\"Get Lineage details for a DagRun\"\"\"     # Convert string datetime into actual datetime"}
{"suffix": "def copy_with(self, **kwargs: typing.Any) -> \"URL\":         #  \\_/   \\______________/\\_________/ \\_________/ \\__/         #   |           |            |            |        |         # scheme     authority       path        query   fragment         return URL(self._uri_reference.copy_with(**kwargs).unsplit())      def copy_set_param(self, key: str, value: typing.Any = None) -> \"URL\":         return self.copy_with(params=self.params.set(key, value))"}
{"suffix": "def makecmdoptions(self):     def __str__(self):         return \"<SvnAuth username=%s ...>\" %(self.username,)  rex_blame = re.compile(r'\\s*(\\d+)\\s*(\\S+) (.*)')  class SvnWCCommandPath(common.PathBase):     \"\"\" path implementation offering access/modification to svn working copies."}
{"suffix": "'transparent': (0, 0, 0, 0), }  RGBA = re.compile(r'rgba\\([ \\n\\r\\t]*(.+?)[ \\n\\r\\t]*\\)') RGB = re.compile(r'rgb\\([ \\n\\r\\t]*(.+?)[ \\n\\r\\t]*\\)') HEX_RRGGBB = re.compile('#[0-9a-f]{6}') HEX_RGB = re.compile('#[0-9a-f]{3}')  def color(string, opacity=1):     if match:         r, g, b, a = tuple(             float(i.strip(' %')) / 100 if '%' in i else float(i) / 255             for i in match.group(1).split(','))         return (r, g, b, a * 255 * opacity)      match = RGB.search(string)     if match:         r, g, b = tuple(             float(i.strip(' %')) / 100 if '%' in i else float(i) / 255             for i in match.group(1).split(','))         return (r, g, b, opacity)      match = HEX_RRGGBB.search(string)"}
{"suffix": "import typing  import flask  app = flask.Flask(\"xmpp-http-upload\") app.config.from_envvar(\"XMPP_HTTP_UPLOAD_CONFIG\")     CORS(app)   def sanitized_join(path: str, root: pathlib.Path) -> pathlib.Path:     result = (root / path).absolute()     if not str(result).startswith(str(root) + \"/\"):         raise ValueError(\"resulting path is outside root\")     return result   def get_paths(base_path: pathlib.Path):     data_file = pathlib.Path(str(base_path) + \".data\")     metadata_file = pathlib.Path(str(base_path) + \".meta\")      return data_file, metadata_file  def load_metadata(metadata_file):         return json.load(f)   def get_info(path: str, root: pathlib.Path) -> typing.Tuple[         pathlib.Path,         dict]:     dest_path = sanitized_join(         path,         pathlib.Path(app.config[\"DATA_ROOT\"]),     )      data_file, metadata_file = get_paths(dest_path)      return data_file, load_metadata(metadata_file)  def stream_file(src, dest, nbytes): @app.route(\"/<path:path>\", methods=[\"PUT\"]) def put_file(path):     try:         dest_path = sanitized_join(             path,             pathlib.Path(app.config[\"DATA_ROOT\"]),         )     except ValueError:         return flask.Response(             \"Not Found\",             404, def put_file(path):         \"application/octet-stream\",     )      dest_path.parent.mkdir(parents=True, exist_ok=True, mode=0o770)     data_file, metadata_file = get_paths(dest_path)      try:         with write_file(data_file) as fout: def generate_headers(response_headers, metadata_headers): @app.route(\"/<path:path>\", methods=[\"HEAD\"]) def head_file(path):     try:         data_file, metadata = get_info(             path,             pathlib.Path(app.config[\"DATA_ROOT\"])         )          stat = data_file.stat()     except (OSError, ValueError):         return flask.Response(             \"Not Found\",             404, def head_file(path): @app.route(\"/<path:path>\", methods=[\"GET\"]) def get_file(path):     try:         data_file, metadata = get_info(             path,             pathlib.Path(app.config[\"DATA_ROOT\"])         )     except (OSError, ValueError):         return flask.Response(             \"Not Found\",             404,"}
{"suffix": "def __str__(self):   class Application:     SOCKTYPES = {         \"tcp\": socket.SOCK_STREAM,         \"udp\": socket.SOCK_DGRAM, def __call__(self, env, start_response):             try:                 length = int(env[\"CONTENT_LENGTH\"])             except AttributeError:                 length = -1             try:                 pr = codec.decode(env[\"wsgi.input\"].read(length))             except codec.ParsingError as e:"}
{"suffix": "def branch_exists(self, branch):         \"\"\"         try:             heads = subprocess.run(                 [\"git\", \"ls-remote\", \"--heads\", self.git_url],                 capture_output=True,                 text=True,                 check=True             )             tags = subprocess.run(                 [\"git\", \"ls-remote\", \"--tags\", self.git_url],                 capture_output=True,                 text=True,                 check=True def resolve_default_branch(self):         \"\"\"         try:             head_branch = subprocess.run(                 [\"git\", \"ls-remote\", \"--symref\", self.git_url, \"HEAD\"],                 capture_output=True,                 text=True,                 check=True def initialize_repo(self):         if self.depth and self.depth > 0:             clone_args.extend(['--depth', str(self.depth)])         clone_args.extend(['--branch', self.branch_name])         clone_args.extend([self.git_url, self.repo_dir])         yield from execute_cmd(clone_args)         logging.info('Repo {} initialized'.format(self.repo_dir))"}
{"suffix": "def _unzip_iter(filename, root, verbose=True):         yield ErrorMessage(filename, e)         return      # Get lists of directories & files     namelist = zf.namelist()     dirlist = set()     for x in namelist:         if x.endswith('/'):             dirlist.add(x)         else:             dirlist.add(x.rsplit('/', 1)[0] + '/')     filelist = [x for x in namelist if not x.endswith('/')]      # Create the target directory if it doesn't exist     if not os.path.exists(root):         os.mkdir(root)      # Create the directory structure     for dirname in sorted(dirlist):         pieces = dirname[:-1].split('/')         for i in range(len(pieces)):             dirpath = os.path.join(root, *pieces[: i + 1])             if not os.path.exists(dirpath):                 os.mkdir(dirpath)      # Extract files.     for i, filename in enumerate(filelist):         filepath = os.path.join(root, *filename.split('/'))          try:             with open(filepath, 'wb') as dstfile, zf.open(filename) as srcfile:                 shutil.copyfileobj(srcfile, dstfile)         except Exception as e:             yield ErrorMessage(filename, e)             return          if verbose and (i * 10 / len(filelist) > (i - 1) * 10 / len(filelist)):             sys.stdout.write('.')             sys.stdout.flush()     if verbose:         print()"}
{"suffix": "import mimetypes import os import os.path import re import socketserver import threading def condition():         if path == \"/js/livereload.js\":             file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"livereload.js\")         elif path.startswith(self.mount_path):             rel_file_path = path[len(self.mount_path):].lstrip(\"/\")             if path.endswith(\"/\"):                 rel_file_path += \"index.html\"             file_path = os.path.join(self.root, rel_file_path)         elif path == \"/\":             start_response(\"302 Found\", [(\"Location\", self.mount_path)])"}
{"suffix": "def parse_native_url(url):         result = re.match(             r'^https?://maker\\.ifttt\\.com/use/'             r'(?P<webhook_id>[A-Z0-9_-]+)'             r'/?(?P<events>([A-Z0-9_-]+/?)+)?'             r'/?(?P<params>\\?.+)?$', url, re.I)          if result:"}
{"suffix": "def interpret(): @app.route(\"/file/<path:path>\", methods=[\"GET\"]) @login_check def file(path):     path = secure_filename(path)     if app.interface.encrypt and isinstance(app.interface.examples, str) and path.startswith(app.interface.examples):         with open(os.path.join(app.cwd, path), \"rb\") as encrypted_file:             encrypted_data = encrypted_file.read()         file_data = encryptor.decrypt(             app.interface.encryption_key, encrypted_data)         return send_file(io.BytesIO(file_data), attachment_filename=os.path.basename(path))     else:         return send_file(os.path.join(app.cwd, path))   @app.route(\"/api/queue/push/\", methods=[\"POST\"])"}
{"suffix": "def process_attachments(followup, attached_files):                 'application/octet-stream',                 size=attached.size,             )             att.save()              if attached.size < max_email_attachment_size:"}
{"suffix": "import os import re from collections import defaultdict  from flask import (     Response, def _add_additional_assets(hook): def login():     from flask_login import current_user      redirect_url = request.args.get(\"redirect\", request.script_root + url_for(\"index\"))     permissions = sorted(         filter(             lambda x: x is not None and isinstance(x, OctoPrintPermission),"}
{"suffix": "import os import Bcfg2.Server.Plugin   def async_run(prog, args):     pid = os.fork()     if pid:         os.waitpid(pid, 0)     else:         dpid = os.fork()         if not dpid:             os.system(\" \".join([prog] + args))         os._exit(0)   class Trigger(Bcfg2.Server.Plugin.Plugin,               Bcfg2.Server.Plugin.Statistics): def __init__(self, core, datastore):                               \"unloading\" % self.data)             raise Bcfg2.Server.Plugin.PluginInitError      def process_statistics(self, metadata, _):         args = [metadata.hostname, '-p', metadata.profile, '-g',                 ':'.join([g for g in metadata.groups])]         for notifier in os.listdir(self.data):             if ((notifier[-1] == '~') or                 (notifier[:2] == '.#') or                 (notifier[-4:] == '.swp') or                 (notifier in ['SCCS', '.svn', '4913'])):                 continue             npath = self.data + '/' + notifier             self.logger.debug(\"Running %s %s\" % (npath, \" \".join(args)))             async_run(npath, args)"}
{"suffix": "class AffinityFilter(filters.BaseHostFilter):     def __init__(self):         self.compute_api = compute.API()      def _affinity_host(self, context, instance_id):         return self.compute_api.get(context, instance_id)['host']   class DifferentHostFilter(AffinityFilter): def host_passes(self, host_state, filter_properties):         if isinstance(affinity_uuids, basestring):             affinity_uuids = [affinity_uuids]         if affinity_uuids:             return not any([i for i in affinity_uuids                               if self._affinity_host(context, i) == me])         # With no different_host key         return True  def host_passes(self, host_state, filter_properties):         if isinstance(affinity_uuids, basestring):             affinity_uuids = [affinity_uuids]         if affinity_uuids:             return any([i for i                           in affinity_uuids                           if self._affinity_host(context, i) == me])         # With no same_host key         return True"}
{"suffix": "from django.conf import settings from django.contrib import messages from django.contrib.auth import REDIRECT_FIELD_NAME from django.utils.translation import ugettext as _ from keystoneclient import exceptions as keystone_exceptions  def handle(self, request, data):         request.session['region_endpoint'] = endpoint         request.session['region_name'] = region_name          redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")          if data.get('tenant', None):             try:"}
{"suffix": "def configure():     register_cli_str('pydev-debug-host', default=None)     register_cli_int('pydev-debug-port', default=None)      register_str('admin_token', default='ADMIN')     register_str('bind_host', default='0.0.0.0')     register_int('compute_port', default=8774)     register_int('admin_port', default=35357) def configure():     # ldap     register_str('url', group='ldap', default='ldap://localhost')     register_str('user', group='ldap', default=None)     register_str('password', group='ldap', default=None)     register_str('suffix', group='ldap', default='cn=example,cn=com')     register_bool('use_dumb_member', group='ldap', default=False)     register_str('dumb_member', group='ldap', default='cn=dumb,dc=nonexistent')"}
{"suffix": "def nav_path(request):     path_parts.append(part)     is_last = len(path_parts) == len(request.path_parts)      item = _item(name=part, href=None)      if not is_last or (is_dir and request.view_func is not view_directory):       item.href = request.get_url(view_func=view_directory,"}
{"suffix": "def _checkPolkitPrivilege(self, sender, conn, privilege):             # bus, and it does not make sense to restrict operations here             return          info = SenderInfo(sender, conn)          # get peer PID         pid = info.connectionPid()          # query PolicyKit         self._initPolkit()         try:             # we don't need is_challenge return here, since we call with AllowUserInteraction             (is_auth, _, details) = self.polkit.CheckAuthorization(                     ('unix-process', {'pid': dbus.UInt32(pid, variant_level=1),                     'start-time': dbus.UInt64(0, variant_level=1)}),                     privilege, {'': ''}, dbus.UInt32(1), '', timeout=3000)         except dbus.DBusException as e:             if e._dbus_error_name == 'org.freedesktop.DBus.Error.ServiceUnknown':"}
{"suffix": "def encode(self):  def constructObject(data):     try:         classBase = eval(data[\"\"] + \".\" + data[\"\"].title())     except NameError:         logger.error(\"Don't know how to handle message type: \\\"%s\\\"\", data[\"\"])         return None     try:         returnObj = classBase()"}
{"suffix": "def sendEmail(sydent, templateName, mailTo, substitutions):             allSubstitutions[k+\"_forhtml\"] = cgi.escape(v.decode('utf8'))             allSubstitutions[k+\"_forurl\"] = urllib.quote(v)          mailString = open(mailTemplateFile).read() % allSubstitutions         rawFrom = email.utils.parseaddr(mailFrom)[1]         rawTo = email.utils.parseaddr(mailTo)[1]         if rawFrom == '' or rawTo == '':             logger.info(\"Couldn't parse from / to address %s / %s\", mailFrom, mailTo)             raise EmailAddressException()         mailServer = sydent.cfg.get('email', 'email.smtphost')         mailPort = sydent.cfg.get('email', 'email.smtpport')         mailUsername = sydent.cfg.get('email', 'email.smtpusername') def sendEmail(sydent, templateName, mailTo, substitutions):                 smtp = smtplib.SMTP(mailServer, mailPort, myHostname)             if mailUsername != '':                 smtp.login(mailUsername, mailPassword)             smtp.sendmail(rawFrom, rawTo, mailString.encode('utf-8'))             smtp.quit()         except Exception as origException:             twisted.python.log.err()"}
{"suffix": "def get_link_re() -> str:      # [text](url) or [text](<url>) or [text](url \"title\")     LINK_RE = NOIMG + BRK + \\         r'''\\(\\s*(<.*?>|((?:(?:\\(.*?\\))|[^\\(\\)]))*?)\\s*((['\"])(.*?)\\12\\s*)?\\)'''     return normal_compile(LINK_RE)  def prepare_realm_pattern(source: str) -> str:"}
{"suffix": "import subprocess import syslog from jadi import component, service, interface  import aj from aj.api.http import BaseHttpHandler class OSAuthenticationProvider(AuthenticationProvider):      def authenticate(self, username, password):         child = None         try:             child = pexpect.spawn('/bin/sh', ['-c', '/bin/su -c \"/bin/echo SUCCESS\" - %s' % username], timeout=5)             child.expect('.*:')             child.sendline(password)             result = child.expect(['su: .*', 'SUCCESS'])"}
{"suffix": "from app import apfell, links, use_ssl from sanic import response from jinja2 import Environment, PackageLoader from sanic_jwt.decorators import scoped, inject_user from app.routes.routes import respect_pivot import urllib.parse  env = Environment(loader=PackageLoader('app', 'templates'))  async def apiui_command_help(request, user):     template = env.get_template('apiui_command_help.html')     if len(request.query_args) != 0:         data = urllib.parse.unquote(request.query_args[0][1])         print(data)     else:         data = \"\"     if use_ssl:"}
{"suffix": "def pref_get(key):         return \"Authentication required\", 401      if key in get_preferences():         return Response(json.dumps({'key': key, 'value': get_preferences()[key]}))     else:         return Response(json.dumps({'key': key, 'error': 'novalue'}))   @app.route(\"/api/preferences/set/<key>/<value>\") def pref_set(key, value):         return \"Authentication required\", 401      get_preferences()[key] = (None if value == 'null' else value)     return Response(json.dumps({'key': key, 'success': ''})), 201   if __name__ == '__main__':"}
{"suffix": "def view_directory(request):       if request.roottype == 'cvs' and file.rev is not None:         row.rev = None         if cfg.options.show_logs:           row.log_file = file.newest_file           row.log_rev = file.rev        if request.roottype == 'svn':"}
{"suffix": "def rreplace(s, old, new, occurrence):      p = Process(config_section)      PASTES_FOLDER = os.path.join(os.environ['AIL_HOME'], p.config.get(\"Directories\", \"pastes\"))     PASTES_FOLDERS = PASTES_FOLDER + '/'      # LOGGING #     publisher.info(\"Feed Script started to receive & publish.\") def rreplace(s, old, new, occurrence):             time.sleep(1)             continue          file_name_paste = paste.split('/')[-1]         if len(file_name_paste)>255:             new_file_name_paste = '{}{}.gz'.format(file_name_paste[:215], str(uuid.uuid4()))             paste = rreplace(paste, file_name_paste, new_file_name_paste, 1)          # Creating the full filepath         filename = os.path.join(PASTES_FOLDER, paste)          dirname = os.path.dirname(filename)         if not os.path.exists(dirname):             os.makedirs(dirname)          decoded = base64.standard_b64decode(gzip64encoded)          with open(filename, 'wb') as f:             f.write(decoded)         '''try:             decoded2 = gunzip_bytes_obj(decoded)         except:             decoded2 =''          type = magic.from_buffer(decoded2, mime=True)          if type!= 'text/x-c++' and type!= 'text/html' and type!= 'text/x-c' and type!= 'text/x-python' and type!= 'text/x-php' and type!= 'application/xml' and type!= 'text/x-shellscript' and type!= 'text/plain' and type!= 'text/x-diff' and type!= 'text/x-ruby':              print('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------')             print(filename)             print(type)             print('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------')         '''          # remove PASTES_FOLDER from item path (crawled item + submited)         if PASTES_FOLDERS in paste:             paste = paste.replace(PASTES_FOLDERS, '', 1)          p.populate_set_out(paste)         processed_paste+=1"}
{"suffix": "def post(self, request, *args, **kwargs):                     code.delete()                     return self.issue_token(user)          return self.issue_token(user)   class RegenerateBackupCodesView(APIView):"}
{"suffix": "async def ip(ctx , *, argument):  @Client.command() async def dirsearch(ctx , *, argument):     Path = TOOLS['dirsearch']; MainPath = getcwd(); chdir(Path)     await ctx.send(f\"**Running Your Dirsearch Scan, We Will Send The Results When It's Done**\")     Process = subprocess.Popen(f'python3 dirsearch.py -u {argument} -e * -b' , shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT) async def dirsearch(ctx , *, argument):  @Client.command() async def arjun(ctx , *, argument):     Path = TOOLS['arjun']; MainPath = getcwd(); chdir(Path)     await ctx.send(f\"**Running Your Arjun Scan, We Will Send The Results When It's Done**\")     await ctx.send(f\"**Note: The Bot Won't Respond Until The Scan is Done. All Of Your Commands Now Will Be Executed After This Process is Done.\")"}
{"suffix": "def load():     database_name = f\"{autocomplete_filepath}{os.path.sep}{RTXConfig.autocomplete_path.split('/')[-1]}\"     conn = sqlite3.connect(database_name)     cursor = conn.cursor()     return True   def get_nodes_like(word,requested_limit):     if len(word) < 2:         return values      floor = word[:-1]     ceiling = floor + 'zz'  def get_nodes_like(word,requested_limit):         if found_fragment is None:              #### Cache this fragment in the database             cursor.execute(\"INSERT INTO cached_fragments(fragment) VALUES(?)\", (word,))             fragment_id = cursor.lastrowid             if debug:                 print(f\"fragment_id = {fragment_id}\")"}
{"suffix": "import sys import rtxcomplete import traceback  #class MainHandler(tornado.web.RequestHandler): #    def get(self): #        self.write(\"Hello, world\") #print __file__  root = os.path.dirname(os.path.abspath(__file__)) rtxcomplete.load() #conn = sqlite3.connect('dict.db') #conn.enable_load_extension(True) #conn.load_extension(\"./spellfix\") #cursor = conn.cursor()  class autoSearch(tornado.web.RequestHandler):      def get(self, arg,word=None):         #print \"match auto\"         try:             limit = self.get_argument(\"limit\")             word = self.get_argument(\"word\")             callback = self.get_argument(\"callback\") #jsonp              result = rtxcomplete.prefix(word,limit)              result = callback+\"(\"+json.dumps(result)+\");\" #jsonp             #result = json.dumps(result) #typeahead                          self.write(result)              def get(self, arg,word=None):         try:             limit = self.get_argument(\"limit\")             word = self.get_argument(\"word\")             callback = self.get_argument(\"callback\")             #print word             #cursor.execute(\"SELECT word FROM spell WHERE word MATCH \\\"\" + word + \"\\\" LIMIT \" + limit)             #cursor.execute(\"SELECT word FROM spell WHERE word MATCH \\\"\" + word + \"*\\\" LIMIT \" + limit) def get(self, arg,word=None):         try:             limit = self.get_argument(\"limit\")             word = self.get_argument(\"word\")             callback = self.get_argument(\"callback\")             #print word             #cursor.execute(\"SELECT word FROM spell WHERE word MATCH \\\"\" + word + \"\\\" LIMIT \" + limit)             #cursor.execute(\"SELECT word FROM spell WHERE word MATCH \\\"\" + word + \"*\\\" LIMIT \" + limit) def get(self, arg,word=None):  class nodesLikeSearch(tornado.web.RequestHandler):     def get(self, arg,word=None):         #try:         if 1 == 1:             limit = self.get_argument(\"limit\")             word = self.get_argument(\"word\")             callback = self.get_argument(\"callback\")             result = rtxcomplete.get_nodes_like(word,limit);             result = callback+\"(\"+json.dumps(result)+\");\"             self.write(result)         #except:         #    print(sys.exc_info()[:])         #    traceback.print_tb(sys.exc_info()[-1])         #    self.write(\"error\")   class defineSearch(tornado.web.RequestHandler):"}
{"suffix": "import tldextract import logging import shutil  from threading import Thread  def get_whois(ip_domain, save_db=False, fetch_from_db=True): def get_cms_details(url):     # this function will fetch cms details using cms_detector     response = {}     cms_detector_command = 'python3 /usr/src/github/CMSeeK/cmseek.py -u {} --random-agent --batch --follow-redirect'.format(url)     os.system(cms_detector_command)      response['status'] = False     response['message'] = 'Could not detect CMS!'"}
{"suffix": "import random from html import escape from os import remove  import magic from flask import Flask, abort, request from PIL import Image def uploadimage():     ):  # if it is not over the limit, it will skip. if it is, it does this.         # if we have gone over our cache limit, let's delete the first entry.         filename = all_files[0][1] + all_files[0][2]         remove(filename)         del all_files[0]         length = len(all_files)"}
{"suffix": "def get(image_file, domain, title, singer, album):     import json     import os     from html import unescape      import requests      api = f\"http://{domain}:7873/bGVhdmVfcmlnaHRfbm93\"      with open(image_file, \"rb\") as f:"}
{"suffix": "print(e)  if form.getvalue('getcert') is not None and serv is not None:     cert_id = form.getvalue('getcert')     if funct.checkAjaxInput(cert_id):         print('error: Nice try')         sys.exit()      cert_path = sql.get_setting('cert_path')     commands = [\"openssl x509 -in \" + cert_path + \"/\" + cert_id + \" -text\"]         print('error: Cannot connect to the server ' + e.args[0])  if form.getvalue('delcert') is not None and serv is not None:     if funct.checkAjaxInput(cert_id):         print('error: Nice try')         sys.exit()      cert_path = sql.get_setting('cert_path')     commands = [\"sudo rm -f \" + cert_path + \"/\" + cert_id]     try:     if form.getvalue('ssl_name') is None:         print('error: Please enter a desired name')     else:         name = form.getvalue('ssl_name')         if funct.checkAjaxInput(name):             print('error: Nice try')             sys.exit()      try:         with open(name, \"w\") as ssl_cert:  if form.getvalue('ipbackend') is not None and form.getvalue('backend_server') is None:     haproxy_sock_port = int(sql.get_setting('haproxy_sock_port'))     backend = form.getvalue('ipbackend')     if funct.checkAjaxInput(backend):         print('error: Nice try')         sys.exit()     cmd = 'echo \"show servers state\"|nc %s %s |grep \"%s\" |awk \\'{print $4}\\'' % (serv, haproxy_sock_port, backend)     output, stderr = funct.subprocess_execute(cmd)     for i in output:  if form.getvalue('ipbackend') is not None and form.getvalue('backend_server') is not None:     haproxy_sock_port = int(sql.get_setting('haproxy_sock_port'))     backend = form.getvalue('ipbackend')     backend_server = form.getvalue('backend_server')     if funct.checkAjaxInput(backend) or funct.checkAjaxInput(backend_server):         print('error: Nice try')         sys.exit()     cmd = 'echo \"show servers state\"|nc %s %s |grep \"%s\" |grep \"%s\" |awk \\'{print $5\":\"$19}\\' |head -1' % (serv, haproxy_sock_port, backend, backend_server)     output, stderr = funct.subprocess_execute(cmd)     print(output[0])  if form.getvalue('backend_ip') is not None:     backend_backend = form.getvalue('backend_backend')     backend_server = form.getvalue('backend_server')     backend_ip = form.getvalue('backend_ip')     backend_port = form.getvalue('backend_port')     if any((funct.checkAjaxInput(backend_backend), funct.checkAjaxInput(backend_server), funct.checkAjaxInput(backend_ip), funct.checkAjaxInput(backend_port))):         print('error: Nice try')         sys.exit()     if form.getvalue('backend_ip') is None:         print('error: Backend IP must be IP and not 0')         sys.exit()         stderr = funct.master_slave_upload_and_restart(serv, cfg, just_save='save')  if form.getvalue('maxconn_select') is not None:     serv = form.getvalue('maxconn_select')     if funct.checkAjaxInput(serv):         print('error: Nice try')         sys.exit()     funct.get_backends_from_config(serv, backends='frontend')  if form.getvalue('maxconn_frontend') is not None:     frontend = form.getvalue('maxconn_frontend')     maxconn = form.getvalue('maxconn_int')      if funct.checkAjaxInput(frontend) or funct.checkAjaxInput(maxconn):         print('error: Nice try')         sys.exit()     if form.getvalue('maxconn_int') is None:         print('error: Maxconn must be integer and not 0')         sys.exit()  if form.getvalue('ip_for_delete') is not None:     haproxy_sock_port = sql.get_setting('haproxy_sock_port')     ip = form.getvalue('ip_for_delete')     table = form.getvalue('table_for_delete')      if funct.checkAjaxInput(ip) or funct.checkAjaxInput(table):         print('error: Nice try')         sys.exit()      cmd = 'echo \"clear table %s key %s\" |nc %s %s' % (table, ip, serv, haproxy_sock_port)     output, stderr = funct.subprocess_execute(cmd)  if form.getvalue('table_for_clear') is not None:     haproxy_sock_port = sql.get_setting('haproxy_sock_port')     table = form.getvalue('table_for_clear')      if funct.checkAjaxInput(table):         print('error: Nice try')         sys.exit()      cmd = 'echo \"clear table %s \" |nc %s %s' % (table, serv, haproxy_sock_port)     output, stderr = funct.subprocess_execute(cmd)     env = Environment(loader=FileSystemLoader('templates/'), autoescape=True,                       extensions=['jinja2.ext.loopcontrols', 'jinja2.ext.do'], trim_blocks=True, lstrip_blocks=True)     template = env.get_template('ajax/list.html')     list_id = form.getvalue('list_select_id')     list_name = form.getvalue('list_select_name')      if funct.checkAjaxInput(list_id) or funct.checkAjaxInput(list_name):         print('error: Nice try')         sys.exit()      haproxy_sock_port = sql.get_setting('haproxy_sock_port')     cmd = 'echo \"show acl #%s\"|nc %s %s' % (list_id, serv, haproxy_sock_port) if form.getvalue('list_id_for_delete') is not None:     haproxy_sock_port = sql.get_setting('haproxy_sock_port')     lists_path = sql.get_setting('lists_path')     lib_path = funct.get_config_var('main', 'lib_path')     ip_id = form.getvalue('list_ip_id_for_delete')     ip = form.getvalue('list_ip_for_delete')     list_id = form.getvalue('list_id_for_delete')     list_name = form.getvalue('list_name')     user_group = funct.get_user_group(id=1)      if any((funct.checkAjaxInput(ip_id), funct.checkAjaxInput(ip), funct.checkAjaxInput(list_id), funct.checkAjaxInput(list_name))):         print('error: Nice try')         sys.exit()      cmd = \"sed -i 's!%s$!!' %s/%s/%s/%s\" % (ip, lib_path, lists_path, user_group, list_name)     cmd1 = \"sed -i '/^$/d' %s/%s/%s/%s\" % (lib_path, lists_path, user_group, list_name)     output, stderr = funct.subprocess_execute(cmd)     ip = form.getvalue('list_ip_for_add')     ip = ip.strip()     ip = funct.is_ip_or_dns(ip)     list_id = form.getvalue('list_id_for_add')     list_name = form.getvalue('list_name')     user_group = funct.get_user_group(id=1)      if any((funct.checkAjaxInput(lists_path), funct.checkAjaxInput(list_id), funct.checkAjaxInput(list_name))):         print('error: Nice try')         sys.exit()      cmd = 'echo \"add acl #%s %s\" |nc %s %s' % (list_id, ip, serv, haproxy_sock_port)     output, stderr = funct.subprocess_execute(cmd)     if output[0]:      env = Environment(loader=FileSystemLoader('templates'), autoescape=True,                       extensions=['jinja2.ext.loopcontrols', 'jinja2.ext.do'], trim_blocks=True, lstrip_blocks=True)     serv = form.getvalue('sessions_select')      if funct.checkAjaxInput(serv):         print('error: Nice try')         sys.exit()      if funct.checkAjaxInput(serv):         print('error: Nice try')         sys.exit()      haproxy_sock_port = sql.get_setting('haproxy_sock_port')      print(template)  if form.getvalue('sessions_select_show') is not None:     serv = form.getvalue('sessions_select_show')     sess_id = form.getvalue('sessions_select_id')      if funct.checkAjaxInput(serv) or funct.checkAjaxInput(sess_id):         print('error: Nice try')         sys.exit()      haproxy_sock_port = sql.get_setting('haproxy_sock_port')      cmd = 'echo \"show sess %s\" |nc %s %s' % (sess_id, serv, haproxy_sock_port)     output, stderr = funct.subprocess_execute(cmd)      if stderr:  if form.getvalue('session_delete_id') is not None:     haproxy_sock_port = sql.get_setting('haproxy_sock_port')     sess_id = form.getvalue('session_delete_id')      if funct.checkAjaxInput(sess_id):         print('error: Nice try')         sys.exit()      if funct.checkAjaxInput(sess_id):         print('error: Nice try')         sys.exit()      cmd = 'echo \"shutdown session %s\" |nc %s %s' % (sess_id, serv, haproxy_sock_port)     output, stderr = funct.subprocess_execute(cmd)     if output[0] != '':     print(\"success: Apache has been %s\" % action)  if form.getvalue('action_service') is not None:     action = form.getvalue('action_service')      if funct.checkAjaxInput(action):         print('error: Nice try')         sys.exit()      if funct.checkAjaxInput(action):         print('error: Nice try')         sys.exit()      if action not in ('start', 'stop', 'restart'):         print('error: wrong action') async def get_runner_overviewServers(**kwargs): if form.getvalue('servaction') is not None:     server_state_file = sql.get_setting('server_state_file')     haproxy_sock = sql.get_setting('haproxy_sock')     enable = form.getvalue('servaction')     backend = form.getvalue('servbackend')      if funct.checkAjaxInput(enable) or funct.checkAjaxInput(backend):         print('error: Nice try')         sys.exit()      cmd = 'echo \"{} {}\" |sudo socat stdio {}'.format(enable, backend, haproxy_sock)  async def get_runner_overviewServers(**kwargs): if serv is not None and form.getvalue('right') is not None:     from jinja2 import Environment, FileSystemLoader      left = form.getvalue('left')     right = form.getvalue('right')      if funct.checkAjaxInput(left) or funct.checkAjaxInput(right):         print('error: Nice try')         sys.exit()      if form.getvalue('service') == 'nginx':         configs_dir = funct.get_config_var('configs', 'nginx_save_configs_dir') async def get_runner_overviewServers(**kwargs):  if form.getvalue('sshdel') is not None:     lib_path = funct.get_config_var('main', 'lib_path')     sshdel = form.getvalue('sshdel')      if funct.checkAjaxInput(sshdel):         print('error: Nice try')         sys.exit()      if funct.checkAjaxInput(sshdel):         print('error: Nice try')         sys.exit()      for sshs in sql.select_ssh(id=sshdel):         ssh_enable = sshs.enable async def get_runner_overviewServers(**kwargs):     import paramiko      user_group = funct.get_user_group()     name = form.getvalue('name')      if funct.checkAjaxInput(name):         print('error: Nice try')         sys.exit()      try:         key = paramiko.pkey.load_private_key(form.getvalue('ssh_cert')) async def get_runner_overviewServers(**kwargs):         funct.logging('SMON', ' Has been update the server ' + ip + ' to SMON ', haproxywi=1, login=1)  if form.getvalue('showBytes') is not None:     serv = form.getvalue('showBytes')      if funct.checkAjaxInput(serv):         print('error: Nice try')         sys.exit()      port = sql.get_setting('haproxy_sock_port')     bin_bout = [] async def get_runner_overviewServers(**kwargs):         print('error: cannot connect to Nginx stat page')  if form.getvalue('waf_rule_id'):     enable = form.getvalue('waf_en')     rule_id = form.getvalue('waf_rule_id')      if funct.checkAjaxInput(enable) or funct.checkAjaxInput(rule_id):         print('error: Nice try')         sys.exit()      haproxy_path = sql.get_setting('haproxy_dir')     rule_file = sql.select_waf_rule_by_id(rule_id) async def get_runner_overviewServers(**kwargs):     os.system(\"rm -f %s\" % script)  if form.getvalue('uploadovpn'):     name = form.getvalue('ovpnname')      if funct.checkAjaxInput(name):         print('error: Nice try')         sys.exit()      if funct.checkAjaxInput(name):         print('error: Nice try')         sys.exit()      ovpn_file = os.path.dirname('/tmp/') + \"/\" + name + '.ovpn'  async def get_runner_overviewServers(**kwargs):     funct.logging(\"localhost\", \" has been uploaded a new ovpn file %s\" % ovpn_file, haproxywi=1, login=1)  if form.getvalue('openvpndel') is not None:     openvpndel = form.getvalue('openvpndel')      if funct.checkAjaxInput(openvpndel):         print('error: Nice try')         sys.exit()      cmd = 'sudo openvpn3 config-remove --config /tmp/%s.ovpn --force' % openvpndel     try: async def get_runner_overviewServers(**kwargs):         funct.logging('localhost', e.args[0], haproxywi=1)  if form.getvalue('actionvpn') is not None:     openvpn = form.getvalue('openvpnprofile')     action = form.getvalue('actionvpn')      if funct.checkAjaxInput(openvpn) or funct.checkAjaxInput(action):         print('error: Nice try')         sys.exit()      if action == 'start':         cmd = 'sudo openvpn3 session-start --config /tmp/%s.ovpn' % openvpn async def get_runner_overviewServers(**kwargs):         funct.logging('localhost', e.args[0], haproxywi=1)  if form.getvalue('scan_ports') is not None:     serv_id = form.getvalue('scan_ports')      if funct.checkAjaxInput(serv_id):         print('error: Nice try')         sys.exit()      server = sql.select_servers(id=serv_id)     ip = ''  async def get_runner_overviewServers(**kwargs):         print(template)  if form.getvalue('viewFirewallRules') is not None:     serv = form.getvalue('viewFirewallRules')      if funct.checkAjaxInput(serv):         print('error: Nice try')         sys.exit()      cmd = [\"sudo iptables -L INPUT -n --line-numbers|sed 's/  */ /g'|grep -v -E 'Chain|target'\"]     cmd1 = [\"sudo iptables -L IN_public_allow -n --line-numbers|sed 's/  */ /g'|grep -v -E 'Chain|target'\"] async def get_runner_overviewServers(**kwargs):  if form.getvalue('geoipserv') is not None:     serv = form.getvalue('geoipserv')      if funct.checkAjaxInput(serv):         print('error: Nice try')         sys.exit()      haproxy_dir = sql.get_setting('haproxy_dir')      cmd = [\"ls \" + haproxy_dir + \"/geoip/\"] async def get_runner_overviewServers(**kwargs):     user_uuid = cookie.get('uuid')     user_id = sql.get_user_id_by_uuid(user_uuid.value)     user_services = sql.select_user_services(user_id)     server_id = form.getvalue('server_id')     service = form.getvalue('service')      if funct.checkAjaxInput(server_id) or funct.checkAjaxInput(service):         print('error: Nice try')         sys.exit()      if '1' in user_services:         if service == 'haproxy':"}
{"suffix": "from flaskbb.extensions import allows, db, celery from flaskbb.user.models import User, Group from flaskbb.forum.models import Post  from hub.forms import ConfigEditForm, BanSearchForm, ConnectionSearchForm from hub.permissions import CanAccessServerHub, CanAccessServerHubAdditional, CanAccessServerHubManagement def get(self):         if server is None:             abort(404)          file_path = os.path.join(server.logs_path, path)         return send_file(file_path, as_attachment=True)"}
{"suffix": "#!/bin/env python from flask import Flask from flask import flash,request,send_file,send_from_directory,redirect,render_template, abort  from werkzeug.utils import secure_filename from ipaddress import ip_address, ip_network def dir_listing(req_path): https://stackoverflow.com/questions/23718236/python-flask-browsing-through-directory-with-files   '''   # Joining the base and the requested path   abs_path = os.path.join(CONFIG['SRV_DIR'], req_path)    # Return 404 if path doesn't exist   if not os.path.exists(abs_path):"}
{"suffix": "from app.module.user.model import UserModel, UserTokenModel from app.module.user import UserSession from werkzeug.routing import BaseConverter, ValidationError from bson.objectid import ObjectId from bson.errors import InvalidId from os import path @login_required def private_static(filename):     # Get path     filepath = path.join(app.config.get(\"PRIVATE_DIR\"), filename)     if path.isfile(filepath):         return send_file(filepath)     # End"}
{"suffix": "import configparser  from flask import Flask, render_template, session, request, flash, redirect, url_for, Response, abort, jsonify, send_file import socket import os import random def get_absolute_path(path):         import os         script_dir = os.path.dirname(__file__)  # <-- absolute dir the script is in         rel_path = path         abs_file_path = os.path.join(script_dir, rel_path)         return abs_file_path      return send_file("}
